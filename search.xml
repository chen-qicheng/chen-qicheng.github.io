<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【生活随笔】卧虎藏龙</title>
      <link href="/2021/11/02/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E5%8D%A7%E8%99%8E%E8%97%8F%E9%BE%99/"/>
      <url>/2021/11/02/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E5%8D%A7%E8%99%8E%E8%97%8F%E9%BE%99/</url>
      
        <content type="html"><![CDATA[<h3 id="把手握紧里面什么都没有，"><a href="#把手握紧里面什么都没有，" class="headerlink" title="把手握紧里面什么都没有，"></a>把手握紧里面什么都没有，</h3><h3 id="把手张开你拥有一切。"><a href="#把手张开你拥有一切。" class="headerlink" title="把手张开你拥有一切。"></a>把手张开你拥有一切。</h3><p>——《卧虎藏龙》台词</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【GetRich】减少开支</title>
      <link href="/2020/09/20/GetRich-%E5%87%8F%E5%B0%91%E5%BC%80%E6%94%AF/"/>
      <url>/2020/09/20/GetRich-%E5%87%8F%E5%B0%91%E5%BC%80%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="减少开支基本思想"><a href="#减少开支基本思想" class="headerlink" title="减少开支基本思想"></a>减少开支基本思想</h3><ol><li><p>致富的<strong>首要原则</strong>：控制开支，不让支出总上升到收入相同水平</p></li><li><p>资金管理<strong>从现在开始</strong>：如果不能从10元中省出1元，那就不会在10万中省出1万。</p></li><li><p>简单但不吝啬：如果觉得某样东西奢侈、不必要和浪费，就不会花钱；然而，当涉及到必要的支出或有价值的事业时，要毫不犹豫花钱。</p></li><li><p>不在花钱中寻找快感：让工作带来的快乐，大于花钱带来快感</p><hr></li></ol><h3 id="步骤一：管理资金："><a href="#步骤一：管理资金：" class="headerlink" title="步骤一：管理资金："></a><strong>步骤一：管理资金：</strong></h3><ol><li><h4 id="消除消费型的贷款"><a href="#消除消费型的贷款" class="headerlink" title="消除消费型的贷款"></a><strong>消除消费型的贷款</strong></h4><p>买房、买车进行合理贷款是必要的，但是要避免在很长的一段时间内承担太多的债务。</p><p>每月处理最低分期付款额度之外，一定要支付更多资金来进一步减少本金。</p><p>快速偿还贷款策略：</p><ul><li>除了主要住房和交通外，从现在开始避免所有的消费型债务！不要超前消费！</li><li>只用现金支付，如果用信用卡付款，请每月付清全部余额。</li><li>每个月已经支付完分期付款的费用后，在剩下的资金中再拿出20%；10%用于进一步消除贷款本金，10%用于投资。</li></ul></li><li><h4 id="合理使用信用卡，避免滥用信用卡"><a href="#合理使用信用卡，避免滥用信用卡" class="headerlink" title="合理使用信用卡，避免滥用信用卡"></a><strong>合理使用信用卡，避免滥用信用卡</strong></h4><p>信用卡的优势：</p><ul><li>相当于两个月无息贷款</li><li>可以获得奖励积分 </li><li>可以跟踪消费账单</li></ul><p>注意：必须在月末<strong>全额还清账单</strong></p></li><li><h4 id="养成了管理个人财务的习惯"><a href="#养成了管理个人财务的习惯" class="headerlink" title="养成了管理个人财务的习惯"></a>养成了管理个人财务的<strong>习惯</strong></h4><ul><li><p>商店购物一定要<strong>讲价</strong></p><p>不是定价商店的话，一般是可以讲价10%的，相当于立即节省下了10%的资金，长期以来会是一笔很大的钱。</p></li><li><p>总是像商店索要<strong>收据</strong></p><p>一定要拿到收据，方便每天结束时跟踪消费费用；如果可以的话，还能把收据作为商务费用作报销，来获得减税。</p></li><li><p>在每天结束时，在你的每日记账单上记录所有费用，每天花费15分钟<strong>管理资金</strong>。</p></li><li><p>尽可能使用信用卡(但每月一定要<strong>还清所有账单</strong>)</p><p>信用卡可以跟踪消费账单，获取信用积分，相当于一月免息贷款。</p></li><li><p>每个月底更新<strong>月度损益表</strong></p><p>建立自己资金流向的跟踪系统，月收入减去总支出可以得到每月的储蓄。可以开始减少不必要的开支，增加储蓄。</p></li></ul></li></ol><hr><h3 id="步骤二：消减开支（大幅降低开支、增加20-30-储蓄的方法）"><a href="#步骤二：消减开支（大幅降低开支、增加20-30-储蓄的方法）" class="headerlink" title="步骤二：消减开支（大幅降低开支、增加20%-30%储蓄的方法）"></a>步骤二：消减开支（大幅降低开支、增加20%-30%储蓄的方法）</h3><ol><li><p>研究我们每月的开支，<strong>每天花费15分钟管理资金</strong></p><ul><li><p>可有可无的费用：冲动购买的东西，目的是为了得到10分钟的满足感，去除之后对我们的生活不会有太大影响</p></li><li><p>看起来很优惠但是不是我们真正需要的东西：被广告吸引的东西，长远来看可以省很多的钱</p></li><li><p>有更便宜的替代品的商品：如星巴克咖啡-&gt;瑞幸咖啡等</p></li></ul></li><li><p>先为自己投资存钱，再花钱（<strong>赚-存-花</strong>）</p><p>每个月先向投资账户里存一笔钱20%的月收入，然后再把剩下的钱花掉，最好银行自动存取。</p></li><li><p>买东西前，<strong>拖延一会儿</strong>问自己几个问题：</p><ul><li>我真的需要这个东西吗？</li><li>三天后我会后悔买了这个东西吗？</li><li>我得工作几个小时才能把花的钱赚回来？</li><li>这笔钱换做投资，未来可以赚多少钱？</li><li>然后说“考虑一下，明天再来。”</li></ul><p>十有八九会是，不会再回去花那笔钱，因为第二天就已经忘记了。</p></li><li><p>如果是购物狂的话，最好方法就是让自己<strong>忙于有目的、有意义的工作</strong></p></li><li><p><strong>销毁多余的信用卡</strong>，只留下一张</p></li><li><p>日常商品，在有特别折扣的时候才购买</p><p>如果你计划购买的商品，只在有特别折扣的时候购买，并批量购买，你可以很容易地再节省15%-25%。</p><p>例如：以前每天要喝一杯30元的星巴克咖啡，在找到15元瑞幸咖啡替代品之后；在网站推出5折购咖啡的活动时，买上几个的月的量。一个月喝咖啡就能省出近700元，且生活质量无明显下降。</p></li><li><p>将生活开销作为公司业务开销</p><p>如果你缴纳20%的个人所得税，那么每次你把一笔费用作为商业费用申报时，你就节省了20%！</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 知识扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GetRich </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【演讲倾听】20/09/17主席湖大演讲</title>
      <link href="/2020/09/18/%E6%BC%94%E8%AE%B2%E5%80%BE%E5%90%AC-20-09-17%E4%B8%BB%E5%B8%AD%E6%B9%96%E5%A4%A7%E6%BC%94%E8%AE%B2/"/>
      <url>/2020/09/18/%E6%BC%94%E8%AE%B2%E5%80%BE%E5%90%AC-20-09-17%E4%B8%BB%E5%B8%AD%E6%B9%96%E5%A4%A7%E6%BC%94%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<p>我今天来参观一下岳麓书院，也是到湖南大学来看一看，几年前到湖南来呢，也看了下湖南大学，但是岳麓书院呢是一直没有去过。所以这次顺便看一看，我对于这个学院在我们传统文化中的地位，影响还是很有感触的，所以我想身临其境来看看。</p><p>别的话就不多说了，想起这两句“<strong>惟楚有才，于斯为盛</strong>”，你看<em>（指着台下）</em>人才济济啊！<em>（掌声雷动）</em></p><p>我的体会是什么呢，一个就是我们湖南人才济济，这个地方代有才人出，都是报效祖国的有功之臣，栋梁之才。历史上的传承对我们这个地方风气的影响非常深远。这里出人才啊，他就有这种渊源关系。</p><p>再有呢我说这个“于斯为盛”，“斯”是指的这个时代，在我们现在这个时代，今年是2020年，明年是2021年，今年是我们第三个五年计划收官之年。明年是十四五计划开始之年。今年这是我们第一个百年（指建党一百周年）脱贫攻坚，全面小康的攻坚收官之年，明年又是我们开启第二个百年长征新政策的一年，在这个时候也是一个英雄辈出的时代。</p><p>我们湖湘子弟，你们这个年纪正当其时，20-30岁。我们第二个百年到2050年（新中国成立100周年），还有30年，你们应该是这个时代结果接力棒的骨干力量。所以我想你们一定不会辜负时代的重托，也会继续传承中华民族，湖湘之地的精神。这里最直接的一个精神就是经世致用，为我们伟大的时代，为我们第二个百年，为我们新时代中国特色社会主义，为中华民族伟大复兴贡献你们的所有才智。请大家真正能够<strong>不负青春，不负韶华</strong>。</p><p>所以祝你们好好学习，珍惜现在这个时光，太宝贵了。利用一切的时间掌握有用的知识，形成成熟的人生观，价值观，走好人生的路，系好人生的第一颗纽扣，祝你们成功！</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【算法】12.矩阵中的路径</title>
      <link href="/2020/09/10/%E7%AE%97%E6%B3%95-12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2020/09/10/%E7%AE%97%E6%B3%95-12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><pre class="line-numbers language-none"><code class="language-none">[[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;],[&quot;s&quot;,&quot;f&quot;,&quot;c&quot;,&quot;s&quot;],[&quot;a&quot;,&quot;d&quot;,&quot;e&quot;,&quot;e&quot;]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 </p><p>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;输出：true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;输出：false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; board.length &lt;&#x3D; 2001 &lt;&#x3D; board[i].length &lt;&#x3D; 200<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>这是一道<strong>深度优先遍历</strong>的题目</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool dfs(char** board, int boardSize, int* boardColSize, char* word,int row, int col, int len)&#123;    if(word[len] &#x3D;&#x3D; &#39;\0&#39;)        return true;&#x2F;&#x2F;边界条件    if( row &lt; 0 || row &gt;&#x3D; boardSize||        col &lt; 0 || col &gt;&#x3D; *boardColSize||        board[row][col] !&#x3D; word[len])        return false;        char temp &#x3D; board[row][col];    board[row][col] &#x3D; &#39;&#x2F;&#39;;&#x2F;&#x2F;遍历过的数据用‘&#x2F;’划除&#x2F;&#x2F;递归实现深度优先遍历    bool res &#x3D;  dfs(board, boardSize, boardColSize, word, row-1, col, len+1)||                dfs(board, boardSize, boardColSize, word, row, col-1, len+1)||                dfs(board, boardSize, boardColSize, word, row+1, col, len+1)||                dfs(board, boardSize, boardColSize, word, row, col+1, len+1);        board[row][col] &#x3D; temp;    return res;&#125;bool exist(char** board, int boardSize, int* boardColSize, char* word)&#123;    for(int i&#x3D;0;i&lt;boardSize;i++)    &#123;        for(int j&#x3D;0; j&lt;*boardColSize;j++)        &#123;            if(dfs(board,boardSize,boardColSize,word,i,j,0))                return true;        &#125;    &#125;    return false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】11.旋转数组的最小数字</title>
      <link href="/2020/09/09/%E7%AE%97%E6%B3%95-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
      <url>/2020/09/09/%E7%AE%97%E6%B3%95-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><p>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：[3,4,5,1,2]输出：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：[2,2,2,0,1]输出：0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><hr><h2 id="顺序查找实现查找："><a href="#顺序查找实现查找：" class="headerlink" title="顺序查找实现查找："></a>顺序查找实现查找：</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">int minArray(int* numbers, int numbersSize)&#123;    int renum &#x3D; numbers[0];        for(int i &#x3D; 0; i &lt;&#x3D; numbersSize; i++)    &#123;        if(numbers[i] &gt;&#x3D; numbers[i+1])        &#123;            renum &#x3D; numbers[i];        &#125;    &#125;    return renum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>顺序查找，没有使用到数组数据已经排好序的特征，可使用二分法利用排序的特征，加快运行速度。</p><h2 id="二分法实现查找："><a href="#二分法实现查找：" class="headerlink" title="二分法实现查找："></a>二分法实现查找：</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">int minArray(int* numbers, int numbersSize)&#123;    int low &#x3D; 0;    int high &#x3D; numbersSize-1;    int mid &#x3D; (low + high)&#x2F;2;    while (low &lt; high)    &#123;        mid &#x3D; (low + high)&#x2F;2;        if(numbers[mid] &lt; numbers[high])        &#123;            high &#x3D; mid ;        &#125;        else if(numbers[mid] &gt; numbers[high])        &#123;            low &#x3D; mid + 1;        &#125;        else if(numbers[mid] &#x3D;&#x3D; numbers[high])        &#123;            high--;        &#125;    &#125;    return numbers[low];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【生活随笔】两幅面孔</title>
      <link href="/2020/09/09/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E4%B8%A4%E5%B9%85%E9%9D%A2%E5%AD%94/"/>
      <url>/2020/09/09/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E4%B8%A4%E5%B9%85%E9%9D%A2%E5%AD%94/</url>
      
        <content type="html"><![CDATA[<p>学习工作要谦逊，虚心踏实</p><p>与人交流要自信，有的放矢</p><p>从一而终的态度不能完全适用于全部的生活</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【生活随笔】脚踏实地</title>
      <link href="/2020/09/04/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E8%84%9A%E8%B8%8F%E5%AE%9E%E5%9C%B0/"/>
      <url>/2020/09/04/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E8%84%9A%E8%B8%8F%E5%AE%9E%E5%9C%B0/</url>
      
        <content type="html"><![CDATA[<p>参加了华为的笔试，最终的结果，三道编程题一个结果都没有出来。</p><p>这次华为笔试就这样挂了，也代表华为工作的路就这样断了。</p><p>面对这样的结果，心里是懊悔又痛苦，，但又不敢表露，仿佛回到了2016年考研。</p><p>招聘找工作遇到这样的困境；毕业论文又一筹莫展，延毕似乎板上钉钉。</p><p>真的感觉自己的研究生生活有点失败 T_T ，我一定是有什么地方做错了！</p><p>是从什么时候开始呢？是什么选择让我陷入如此的困境呢？</p><p>是从选择导师、选择方向的时候？还是去深圳实习的时候？</p><p>因为没有去面对一次次的小困难而导致现在的大困境吗？</p><p>是有什么不好的习惯、错误的想法让我一步步沦落成现在这样吗？</p><p>我真的……</p><hr><p>行有不得，反求诸己；确实是我<strong>眼高手低，自以为是</strong>了。</p><p>从拿到湖大研究生的通知书起就开始飘飘然了，</p><p>不断的被别人表扬、夸奖，认为自己做到了许多人做不到的事情，</p><p>却不想湖大也是卧虎藏龙，研究生也有很多挑战。</p><p>感觉自己硬件能力也还不错，挑战从未接触过的射频与微波专业。</p><p>但自己硬件基础是真的薄弱，在研究学习上面遇到一个个难以解决的问题，</p><p>没有去直面面对，选择逃避和拖延。</p><p>在常州无线电给刘老师做事情，程序问题很快就能解决。</p><p>感觉自己做嵌入式真的很不错，瞧不起自己选择的专业。</p><p>当接触的事情越来越多，想做的事情也越来越多，</p><p>甚至规划好了5年、10年后的生活。却唯独没有做好眼前的事。</p><p>甚至觉得有些眼前的事情是阻碍，或者不屑于去做。</p><p>慢慢的遇到困难的时候，就总是觉得这是别人的问题，是别人在为难我。</p><p>就更不愿意接触，交流心声了。</p><p>自己越来越像一个孤岛，飘离在大海之上，与身边的人渐渐远离。</p><p>都说“<strong>脚踏实地，仰望星空</strong>”，现在我只仰望星空，没有脚踏实地，走着走着就掉坑里了。</p><p><strong>亡羊补牢，为时不晚。现在是要从坑里爬出来了。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【算法】10.2青蛙跳台阶问题</title>
      <link href="/2020/08/29/%E7%AE%97%E6%B3%95-10-2%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
      <url>/2020/08/29/%E7%AE%97%E6%B3%95-10-2%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：n &#x3D; 2输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：n &#x3D; 7输出：21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 3：</p><pre class="line-numbers language-none"><code class="language-none">输入：n &#x3D; 0输出：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">0 &lt;&#x3D; n &lt;&#x3D; 100<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof">https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/image-20200829165408735.png" alt="青蛙跳台阶，最后一跳"></p><p>设跳上 n 级台阶有 f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2 级台阶。</p><ul><li>当为 1 级台阶： 剩 n-1个台阶，此情况共有 f(n-1)种跳法；</li><li>当为 2 级台阶： 剩 n-2 个台阶，此情况共有 f(n-2) 种跳法。</li></ul><p>f(n) 为以上两种情况之和，即 f(n)=f(n-1)+f(n-2) ，本题就转变为<strong>斐波那契数列</strong>了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int numWays(int n)&#123;    unsigned f0 &#x3D; 1, f1 &#x3D; 1, f2 &#x3D; f0 + f1;    int a &#x3D; 1e9 + 7;    if(n &lt; 2)        return 1;    for(int i &#x3D; 0; i&lt;n-1; ++i)    &#123;        f2 &#x3D; (f0 + f1) % a;        f0 &#x3D; f1;        f1 &#x3D; f2;    &#125;    return f2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】10.1斐波那契数列</title>
      <link href="/2020/08/29/%E7%AE%97%E6%B3%95-10-1%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
      <url>/2020/08/29/%E7%AE%97%E6%B3%95-10-1%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p><pre class="line-numbers language-none"><code class="language-none">F(0) &#x3D; 0,   F(1) &#x3D; 1F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1： </p><pre class="line-numbers language-none"><code class="language-none">输入：n &#x3D; 2输出：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：n &#x3D; 5输出：5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">0 &lt;&#x3D; n &lt;&#x3D; 100<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof">https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="递归法："><a href="#递归法：" class="headerlink" title="递归法："></a>递归法：</h2><p>整个结果都是由多个<code>F(N) = F(N - 1) + F(N - 2)</code>组成，所以可以使用递归方法来实现。</p><p><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/image-20200829161929506.png" alt="斐波那契数列"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int fib(int n)&#123;    if(n &lt; 2)return n &#x3D;&#x3D; 0? 0: 1;return fib(n-1) + fib(n-2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>递归法<strong>代码极其简洁</strong>，但是<strong>时间复杂度巨高</strong>。使用递归法 Leetcode 无法测试通过。</p><h2 id="循环法"><a href="#循环法" class="headerlink" title="循环法"></a>循环法</h2><p>使用<strong>快慢指针</strong>，循环实现斐波那契数列。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int fib(int n)&#123;    unsigned int f0 &#x3D; 0, f1 &#x3D; 1, f2 &#x3D; f0 + f1;    int a &#x3D; 1e9 + 7;    if(n &#x3D;&#x3D; 0)        return 0;    for(int i &#x3D; 0; i&lt;n-1; i++)    &#123;        f2 &#x3D; (f0 + f1) % a;        f0 &#x3D; f1;        f1 &#x3D; f2;    &#125;    return f2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【生活随笔】 勇</title>
      <link href="/2020/08/27/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E5%8B%87/"/>
      <url>/2020/08/27/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E5%8B%87/</url>
      
        <content type="html"><![CDATA[<p>人生来就不是勇敢的，有所畏惧是人类生存的本能。在远古的时代，因为人类有所畏惧，人类才能躲避危险，才能健康生存。<strong>所以勇气并不是人的本性，畏惧和胆怯才是</strong>。</p><p>但是，现代的畏惧和远古时期的畏惧有所不同。我常常会畏惧，畏惧与人交流。心中有想法，但害怕说错话，就干脆不说；不愿意和不熟悉的人聊天；在某些特定的场合，会脸红心跳加速，紧张到说不出话。还会畏惧新的开始。在学习投资技能的时候，感受到失去的痛苦远大过于收获的快乐，不敢再进行下去；接触新的事物，常觉得自己准备的不够好也不够充分，始终不愿开始第一步。生活中总有这样那样的事情，因为胆怯而错过时机，因为胆怯而毫无精进。我十分苦恼，也十分懊悔，想克服胆怯，也想充满勇气的去面对一切大小困难。<strong>或许说谁不希望自己能无所畏惧，一往无前呢？</strong></p><p>但是这样的胆怯，这样的畏惧感要怎么克服呢？我觉得克服胆怯，<strong>需要有充分的支持，不害怕犯错，不害怕失败</strong>。这说起来好像很容易，但做起来一定会是各种困难。其中最重要的一定是，知道自己最低的底线在哪里。就像社会有养老保险，就算无妻无儿，也会有国家的保障，不会老无所养；像攀岩者报名的保险绳，知道就算不小心失足滑倒，也会有生命的保障，才敢放手攀登。有了底线，就敢一次次的勇敢尝试；有了一次一次的尝试，就有熟能生巧的熟练；有了熟能生巧的熟练，才会有旁人看上去的无所畏惧的勇气，才会面对困难时云淡风轻的态度。</p><p>总的来说，我是缺乏勇气的。投资缺乏勇气，那要更多学习投资的知识，积累更多的资金，让投资得更有底气；做最便宜的尝试，就不那么害怕失去了。与人交流缺乏勇气，找到一个可以全盘托出心里话的人，遇到了困难能够指点请教的人。<strong>看来我真的需要找一位女朋友了</strong>；招聘没底气，如果手握着一份offer，心里底气会更大一些吧。毕业没底气，还是早点把MATLAB仿真做出来，早点把小论文写出来，这样心里就更有底一些，就不会这么慌张了。</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【算法】07重建二叉树</title>
      <link href="/2020/08/22/%E7%AE%97%E6%B3%95-07%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/08/22/%E7%AE%97%E6%B3%95-07%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 </p><p>例如，给出</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">前序遍历 preorder &#x3D; [3,9,20,15,7]中序遍历 inorder &#x3D; [9,3,15,20,7]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>返回如下的二叉树：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">  3 &#x2F; \9  20  &#x2F;  \ 15   7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>限制：</p><p>0 &lt;= 节点个数 &lt;= 5000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize)&#123;    if(preorder &#x3D;&#x3D; NULL || inorder &#x3D;&#x3D; NULL || preorderSize &lt;&#x3D; 0 || inorderSize &lt;&#x3D; 0)    &#123;        return NULL;    &#125;        struct TreeNode* root &#x3D; (struct TreeNode*)malloc(sizeof(struct TreeNode));    root-&gt;val &#x3D; preorder[0];&#x2F;&#x2F;根节点    int i &#x3D; 0;    while(inorder[i] !&#x3D; preorder[0])&#x2F;&#x2F;中序遍历中找出根节点位置    &#123;        i++;    &#125;    root-&gt;left &#x3D; buildTree(&amp;preorder[1],i,&amp;inorder[0],i);    root-&gt;right &#x3D; buildTree(&amp;preorder[i+1],preorderSize-i-1,&amp;inorder[i+1],preorderSize-i-1);    return root;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_2020082220352211.jpg" alt="递归顺序"></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】06从尾到头打印链表</title>
      <link href="/2020/08/22/%E7%AE%97%E6%B3%95-06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/08/22/%E7%AE%97%E6%B3%95-06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p>示例 1：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">输入：head &#x3D; [1,3,2]输出：[2,3,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>限制：</p><pre class="line-numbers language-none"><code class="language-none">0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="使用辅助内存空间"><a href="#使用辅助内存空间" class="headerlink" title="使用辅助内存空间"></a>使用辅助内存空间</h2><ol><li>算出链表长度</li><li>创建辅助链表空间</li><li>循环，从尾到头存入新的地址空间返回</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     struct ListNode *next; * &#125;; *&#x2F;&#x2F;** * Note: The returned array must be malloced, assume caller calls free(). *&#x2F;int* reversePrint1(struct ListNode* head, int* returnSize)&#123;    int num &#x3D; 0;    if(head &#x3D;&#x3D; NULL)    &#123;        * returnSize &#x3D; 0;        return NULL;    &#125;    struct ListNode* q &#x3D; head;    while(q !&#x3D; NULL)&#x2F;&#x2F;计算链表数据个数    &#123;        num++;        q &#x3D; q -&gt; next;    &#125;    * returnSize &#x3D; num;    int* p &#x3D; (int*)malloc(sizeof(int) * num);    &#x2F;&#x2F;创建新地址空间,存储反转数据    for(int i&#x3D;0; i&lt;num; i++)    &#123;        p[num-1-i] &#x3D; head -&gt; val;        head &#x3D; head -&gt; next;    &#125;    return p;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">int* reversePrint2(struct ListNode* head, int* returnSize)&#123;    if(head &#x3D;&#x3D; NULL)    &#123;        *returnSize &#x3D; 0;        return malloc(sizeof(int) * 10000);    &#125;    int *ans &#x3D; reversePrint(head-&gt;next, returnSize);    ans[(*returnSize)++] &#x3D; head-&gt;val;    return ans;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【GetRich】思路总览</title>
      <link href="/2020/08/13/GetRich-%E6%80%9D%E8%B7%AF%E6%80%BB%E8%A7%88/"/>
      <url>/2020/08/13/GetRich-%E6%80%9D%E8%B7%AF%E6%80%BB%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h2 id="顶层设计"><a href="#顶层设计" class="headerlink" title="顶层设计"></a>顶层设计</h2><ol><li><h3 id="思想-习惯"><a href="#思想-习惯" class="headerlink" title="思想/习惯"></a>思想/习惯</h3></li><li><h3 id="财富定义"><a href="#财富定义" class="headerlink" title="财富定义"></a>财富定义</h3><p>富人、中产、穷人的现金流</p><p>财富的四个水平</p></li></ol><h2 id="行动指南"><a href="#行动指南" class="headerlink" title="行动指南"></a>行动指南</h2><ol><li><h3 id="目标-计划"><a href="#目标-计划" class="headerlink" title="目标/计划"></a>目标/计划</h3></li><li><h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3><ol><li>主动收入</li><li>被动收入</li></ol></li><li><h3 id="节流-减少不必要的开支"><a href="#节流-减少不必要的开支" class="headerlink" title="节流(减少不必要的开支)"></a>节流(减少不必要的开支)</h3></li><li><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><p>建立收支监测系统</p></li><li><h3 id="增值"><a href="#增值" class="headerlink" title="增值"></a>增值</h3><p>指数    <em>年利率8~12%</em></p><p>基金    <em>年利率10~25%</em></p><p>股票    <em>年利率15~50%</em></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 知识扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GetRich </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】中断处理过程</title>
      <link href="/2020/08/13/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/08/13/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>中断的定义：</p><p>指 CPU 在正常执行程序的时候，由于内部/外部事件的触发、或由程序预先设定，而引起 CPU <strong>暂时中止当前正在执行的程序</strong>；</p><p>保存被执行程序相关信息到栈中，转而去执行为内部/外部事件、或由程序预先设定的事件的<strong>中断服务子函数</strong>；</p><p>待执行完中断服务子函数后，CPU 再获取被保存在栈中被中断的程序的信息，<strong>继续执行被中断的程序</strong>，这一过程叫做中断。</p><p>中断处理过程中一般分为以下几个<strong>步骤</strong>：</p><p>请求中断  -&gt;  中断响应  -&gt;  保护现场  -&gt;  中断服务  -&gt;  恢复现场  -&gt;  中断返回</p><p>中断的几个概念：</p><p>中断向量：中断服务程序的入口地址。</p><p>中断向量表：把系统中所有的中断类型码机器对应的中断向量按一定的规律存放在一个区域内，这个存储区域就叫做中断向量表。</p><p>中断源：软中断/内中断、外中断/硬件中断、异常等。</p><p>中断嵌套：中断系统中正在执行一个中断服务时，有另一个优先级更高的中断提出中断请求，会暂时中止当前正在执行的级别较低的中断源的服务程序，区处理级别更高的中断源，待处理完毕，在返回到被中止了的中断服务函数继续执行。</p><hr><p>参考：</p><ul><li><a href="https://www.nowcoder.com/questionTerminal/2e85847c06684c2faeaf8728f72e5045?toCommentId=426573">简述处理器中断处理的过程（中断向量、中断保护现场、中断嵌套、中断返回等）</a></li><li><a href="https://blog.csdn.net/qq_38410730/article/details/80905551?ops_request_misc=%7B%22request_id%22:%22159730365019724846417672%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=159730365019724846417672&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~rank_blog_v1-2-80905551.pc_v1_rank_blog_v1&utm_term=2014&spm=1018.2118.3001.4187">【机试题】2014大疆嵌入式笔试题（附超详细解答，下篇）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【招聘】美团嵌入式笔试</title>
      <link href="/2020/08/13/%E6%8B%9B%E8%81%98-%E7%BE%8E%E5%9B%A2%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AF%95/"/>
      <url>/2020/08/13/%E6%8B%9B%E8%81%98-%E7%BE%8E%E5%9B%A2%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><blockquote><p>美团对于商家的评价体系是 1-5 星评价体系，用户在完成订单之后可以对商家打 1/2/3/4/5 星，而在客户端上，商家的评级却不一定是整数，而是会显示小数点后的一位。很显然这就需要一个计算器了，小美拥有了一些商户的评价数据，希望可以计算出商家在客户端上显示出的评分。</p><p>这个评分的计算非常简单，就是对该商家的所有客户的星级评价做求一个平均，然后<strong>去尾法显示小数点后的一位</strong>即可，例如平均得分是3.55，则显示的是3.5。例如某商家获得了 1-5星评价各一个，则显示的评分是 (1+2+3+4+5)/5=3.0。</p><p>如果商家没有获得评价，则显示0.0。</p><p>输入描述</p><p><code>输入包含5个整数，依次分别表示商家获得 1 星到 5 星的评价数量，每一种评价的数量都不大于1000。</code></p><p>输出描述</p><p><code>输出仅包含一个保留一位的小数，表示商家在客户端上显示的评级。</code></p><p>样例输入</p><p><code>2 2 1 1 2</code></p><p>样例输出</p><p><code>2.8</code></p></blockquote><h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><blockquote><p>2020年的618不再仅仅是购物节啦，同时也是美团外卖节，小美早早就准备好了各种减满代金券，为了最大程度的“省钱”，当然是选择把这些代金券都用光啦！</p><p>这些代金券都有一个使用门槛，即满多少元的订单才可以使用。如果使用一个二元组 &lt;x,y&gt; 表示一张代金券，即需要满 x 元才能优惠 y 元，那么需要注意的是，并不是所有代金券的 x 都是大于等于 y 的，良心美团也会推出一些 x&lt;y 的代金券。如果 x&lt;y，例如 x=1，y=2，则购买 1 元商品的情况下无需付款，也不会退款给用户。</p><p>请问小美如果想用挖这些代金券，在保证总付款金额最小的情况下，她最多购买多少钱的外卖呢？</p><p>说明：</p><ol><li>一个订单只能用一张代金券。</li><li>同时满足总付款金额最少，且购买的外卖价值最高，例如两个优惠都是 1 元的外卖，一个原价 3 元另一个原价 4 元，则选 4 元的。</li><li>由于美团商户很多，所以对于任何一个价格我们都可以找到至少一种商品购买。</li></ol><p>输出描述</p><pre class="line-numbers language-none"><code class="language-none">输出仅包含两个正整数，中间用空格隔开，分别表示小美购买的外卖价值和她的实际付款金额。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>样例输入</p><p><code>3</code></p><p><code>5 3</code></p><p><code>10 5</code></p><p><code>1 2</code></p><p>样例输出</p><p><code>17 7</code></p></blockquote><h2 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h2><blockquote><p>小美是美团的一名鲜花快递员，鲜花是一种保质期非常短的商品，所以需要尽快送到客户的手中，公司对于骑手的一个要求就是要规划送花的线路，使得骑手送完所有订单走的路程尽可能的少。（骑手开始派送时带走了所有需要派送的花，不必每单后返回花店，路程结算是从花店出发，到送完最后一名客户为止，不计算从最后一名客户家回到花店的时间）</p><p>公司对于骑手的绩效评价是取决于两个指标，一是从花店到所以客户地址的距离和，另一个是骑手实际走的路程。</p><p>设花店始终位于 1 号位置，客户共有 n-1 个，其编号为 2~n。令 dis(i,j) 表示 i 号位置到 j 号位置的距离，即分别计算<img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/image-20200813140245795.png" alt="image-20200813140245795">，和骑手实际所走的<strong>最短路程</strong>。</p><p>为了简化问题，我们约束这 n 个位置构成的是一棵<strong>树</strong>，即只有 n-1 条边在其中互相连接，且保证 n 个点彼此联通。</p><p>输入描述</p><p><code>输入第一行包含一个正整数 n ，即花店和客户的总和。（1&lt;=n&lt;=30000）</code></p><p><code>接下来有 n-1 行，每行有三个整数 u,v,w，表示在 u 和 v 之间存在一条距离为 w 的道路。（1&lt;=w&lt;=1000）</code></p><p>输出描述</p><p><code>输出包含两个整数，中间用空格隔开，分别表示花店到所有客户地址的距离和和骑手实际走的路程。</code></p><p>样例输入</p><p><code>5</code></p><p><code>1 2 3</code></p><p><code>1 3 1</code></p><p><code>1 4 2</code></p><p><code>2 5 1</code></p><p>样例输出</p><p><code>10 10</code></p></blockquote><h2 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h2><blockquote><p>外卖节即将过去了，小美还有很多代金券没有消费掉，美团面向小美这样的用户推出了一个新的活动，即代金券消消乐活动。系统会把小美的代金券打乱顺序排成一排，小美可以进行任意多次如下操作：</p><p>如果存在相邻的两个代金券金额相等，设其面额为 x，小美可以使用这两张代金券换一张面额为 x+1 的代金券，并将其仍放在原来两张券的位置上，每进行一次这样的操作，小美就可以获得 1 元可以无限使用的奖励金。</p><p>小美觉得奖励金可太香了，因此她想获得尽可能多的奖励金，请问她最多可以获得多少奖励金。</p><p>输入描述</p><p><code>输入第一行仅包含一个正整数 n，表示小美拥有的代金券数量。（1&lt;=n&lt;=500）</code></p><p><code>输入的第二行包含 n 个正整数，每个整数 x 表示一张代金券的面额，同时这也是系统排出的代金券顺序。（1&lt;=x&lt;=100）</code></p><p>输出描述</p><p><code>输出仅包含一个整数，表示小美最多可以获得的奖励金数量。</code></p><p>样例输入</p><p><code>5</code></p><p><code>1 1 1 1 1</code></p><p>样例输出</p><p>3</p><p>提示</p><p><code>样例解释：</code></p><p><code>&#123;1,1,1,1,1&#125; -&gt;&#123;1,1,1,2&#125; -&gt;&#123;1,2,2&#125; -&gt; &#123;1,3&#125;</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 招聘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【招聘】中兴嵌入式面经</title>
      <link href="/2020/08/13/%E6%8B%9B%E8%81%98-%E4%B8%AD%E5%85%B4%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%9D%A2%E7%BB%8F/"/>
      <url>/2020/08/13/%E6%8B%9B%E8%81%98-%E4%B8%AD%E5%85%B4%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="面试邀约："><a href="#面试邀约：" class="headerlink" title="面试邀约："></a>面试邀约：</h2><p>之前投了简历，官网还没审核通过，中午就突然打电话过来，邀约在当天晚上7点钟面试。越过笔试，直接面试。有些突然</p><h2 id="面试情况："><a href="#面试情况：" class="headerlink" title="面试情况："></a>面试情况：</h2><p>面试是两位面试官与我微信语音面试，两位面试官都是做大数据的，而且我准备的并不充分，还十分紧张，所以表现得并不好。</p><h2 id="面试内容："><a href="#面试内容：" class="headerlink" title="面试内容："></a>面试内容：</h2><ol><li><p>做一下简单的自我介绍</p></li><li><p>别人对你的评价是什么样的？</p></li><li><p>你觉得自己的缺点是什么？</p></li><li><p>介绍一下自己最满意的一个项目，介绍一下你在项目中的工作？</p></li><li><p>介绍一下TCP/IP协议，讲解一下scoket？</p></li><li><p>会什么编程语言？</p></li><li><p>讲解一下C语言的数据类型？</p></li><li><p>如果你的领导让你在微信公众号发布一篇技术文章，要求文章的阅读量达到两万，你会怎么做？</p></li><li><p>为什么会选择中兴？</p></li><li><p>会不会选择像深圳这样的一线城市？</p></li><li><p>你对我们还有什么问题？</p><p>嵌入式岗位在长沙情况怎么样？</p><p>如果是电子与通信专业的学生可以选择软件开发岗位吗？专业不匹配的情况</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 招聘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【FreeRTOS】什么是 FreeRTOS？</title>
      <link href="/2020/08/11/FreeRTOS-%E4%BB%80%E4%B9%88%E6%98%AFFreeRTOS%EF%BC%9F/"/>
      <url>/2020/08/11/FreeRTOS-%E4%BB%80%E4%B9%88%E6%98%AFFreeRTOS%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<ul><li>Free 是免费的、 自由的、不受约束的意思，</li><li>RTOS 是 Real Time Operating System，即实时操作系统；RTOS 不是指某一个确定的系统，而是指一类系统。比如 UCOS，FreeRTOS，RTX，RT-Thread 等这些都是 RTOS 类操作系统。 </li></ul><p>所以 FreeROTS 是一个免费的 RTOS 类系统。</p><hr><p>RTOS最关键的部分是<strong>实时多任务内核</strong>，实际上，一个处理器核心在某一时刻只能运行一个任务。操作系统中任务调度器的责任就是决定在某一时刻究竟运行哪个任务。任务调度在各个任务之间的切换非常快！造成了同一时刻有多个任务同时运行的错觉。</p><p>RTOS的基本功能包括，<strong>任务管理</strong>、定时器管理、存储器管理、资源管理、事件管理、系统管理、消息管理、队列管理、旗语管理等。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言】位运算</title>
      <link href="/2020/08/10/C%E8%AF%AD%E8%A8%80-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2020/08/10/C%E8%AF%AD%E8%A8%80-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>实例1</p><blockquote><p>在一个多任务嵌入式系统中，有一个CPU可直接寻址的32位寄存器REGn，地址为0x1F000010，编写一个安全的函数，将寄存器REGn的指定位反转（要求保持其他bit的值不变）。</p></blockquote><h2 id="特定位取反用"><a href="#特定位取反用" class="headerlink" title="特定位取反用^="></a><strong>特定位取反用^=</strong></h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">void bit_reverse(uint32_t nbit)&#123;    ((volatile unsigned int *)0x1F000010) ^&#x3D; (0x01 &lt;&lt; nbit);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><p>实例2</p><blockquote><p>给定一个整型变量a，写两段代码，第一个设置a的bit3，第二个清除a的bit3。</p></blockquote><h2 id="特定位置1用"><a href="#特定位置1用" class="headerlink" title="特定位置1用|="></a><strong>特定位置1用|=</strong></h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define BIT3 (0x01 &lt;&lt; 3)static a;void setBit3(void)&#123;a |&#x3D; (0x01 &lt;&lt; 3);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="特定位清零用-amp"><a href="#特定位清零用-amp" class="headerlink" title="特定位清零用&amp;=~"></a><strong>特定位清零用&amp;=~</strong></h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define BIT3 (0x01 &lt;&lt; 3)static a;void clearBit3(void)&#123;a &amp;&#x3D; ~(0x01 &lt;&lt; 3);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="读取第n位的值"><a href="#读取第n位的值" class="headerlink" title="读取第n位的值"></a><strong>读取第n位的值</strong></h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">(a&gt;&gt;n)&amp;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p>参考：</p><ul><li><a href="https://blog.51cto.com/9291927/1784135">嵌入式linux C语言（一）——位运算的使用</a></li><li><a href="https://blog.csdn.net/hanfeng_1999/article/details/51354905">2.2.位与位或位异或在操作寄存器时的特殊作用</a></li><li><a href="https://blog.csdn.net/qq_877667836/article/details/82868544">嵌入式开发中对寄存器的位操作</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】无锁编程</title>
      <link href="/2020/08/10/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/08/10/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>互斥锁：锁机制是同一时刻只允许一个线程执行一个关键部分的代码。</p><h2 id="无锁编程："><a href="#无锁编程：" class="headerlink" title="无锁编程："></a>无锁编程：</h2><p>无锁编程：不使用锁的情况下实现<strong>多线程之间对变量同步和访问</strong>的一种程序设计实现方案。</p><p>无锁编程具体使用和考虑到的技术方法包括：</p><ol><li><strong>原子操作</strong>（atomic operations）</li><li>内存栅栏（memory barriers）</li><li>内存顺序冲突（memory order）</li><li>指令序列一致性（consistency）</li><li>ABA 问题</li></ol><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>最基础最重要的是操作的原子性或说原子操作。原子操作可以理解为在执行完毕之前不会被任何其它任务或事件中断的一系列操作。<strong>原子操作是非阻塞编程最核心基本的部分</strong>，没有原子操作的话，操作会因为中断异常等各种原因引起数据状态的不一致从而影响到程序的正确。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>最常用的原子操作又是 COMPARE AND SWAP (CAS)，几乎所有的 CPU 指令集都支持 CAS 的原子操作。</p><p>CAS 操作行为是比较某个内存地址处的内容是否和期望值一致，如果一致则将该地址处的数值替换为一个新值。CAS 能够操作的位数越多，使用它来实现锁无关的数据结构就越容易。</p><p>CAS 操作具体的实现原理主要是两种方式：总线锁定和缓存锁定。</p><h2 id="ABA的问题"><a href="#ABA的问题" class="headerlink" title="ABA的问题"></a>ABA的问题</h2><p>线程 a 先读取了要对比的值v后，被线程 b 抢占了，线程 b 对 v 进行了修改后又改会 v 原来的值，线程a继续运行执行 CAS 操作的时候，无法判断出 v 的值被改过又改回来。</p><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/liusuper2088/article/details/41047501">无锁编程技术及实现</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】实时操作系统与非实时操作系统</title>
      <link href="/2020/08/10/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E9%9D%9E%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/08/10/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E9%9D%9E%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>实时操作系统是保证在一定时间限制内完成特定功能的操作系统，实时性最主要的含义是：任务的最迟完成时间是可以确认预知的。</p><p>实时操作系统分为<strong>硬实时</strong>、<strong>软实时</strong></p><ul><li>硬实时：要求在<strong>规定时间内</strong>必须完成操作，这是在操作系统设计时保证的</li><li>软实时：只要按照<strong>任务的优先级</strong>，尽可能地完成任务即可</li></ul><p>常见的实时系统有：ThreadX、FreeRTOS、ucOS</p><p>常见的非实时系统有：windows、linux、Android</p><table><thead><tr><th>比较项目</th><th>非实时系统</th><th>实时系统</th></tr></thead><tbody><tr><td>交互能力</td><td>较强</td><td>较弱</td></tr><tr><td>响应时间</td><td>秒级</td><td>毫秒、微妙级</td></tr><tr><td>可靠性</td><td>一般</td><td>较高</td></tr><tr><td>进程完成的截止期限</td><td>没有</td><td>有</td></tr><tr><td>进程切换的要求</td><td>一般</td><td>快</td></tr><tr><td>内核</td><td>非可剥夺（体现公平）</td><td>可剥夺（体现优先级别）</td></tr></tbody></table><hr><p>参考</p><ul><li><p><a href="https://blog.csdn.net/beauytlife_1985/article/details/82115522">实时系统和非实时系统的区别</a></p></li><li><p><a href="https://blog.csdn.net/weixin_43581427/article/details/104222153">实时操作系统与非实时操作系统（包含 硬实时和软实时）</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言】内存复制函数memcpy</title>
      <link href="/2020/08/10/C%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E5%A4%8D%E5%88%B6%E5%87%BD%E6%95%B0memcpy/"/>
      <url>/2020/08/10/C%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E5%A4%8D%E5%88%B6%E5%87%BD%E6%95%B0memcpy/</url>
      
        <content type="html"><![CDATA[<h2 id="内存复制函数"><a href="#内存复制函数" class="headerlink" title="内存复制函数"></a>内存复制函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">void * memcpy (void * destination, const void * source, size_t num);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 source 指向的地址处的 <strong>num 个字节</strong>，拷贝到 destination 指向的地址处，注意，<strong>是 num 个字节</strong>！</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><blockquote><p>下面这段程序的运行结果？</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int main ()&#123;    int a[10] &#x3D; &#123;0,1,2,3,4,5,6,7,8,9&#125;;    memcpy(a + 3, a, 5);    for(int i &#x3D; 0; i&lt;10; i++)    &#123;        printf(&quot;%d&quot;, a[i]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>解答：0 1 2 0 1 5 6 7 8 9</p><p>因为 memcpy 的最后一个参数是需要拷贝的字节的数目！一个 int 类型占 4 个字节！这样的话，本题 5 个字节，实际上只能移动 2 个数字<strong>（往大的去）</strong>。</p><p>如果想要达到将 a 地址开始的 5 个元素拷贝到 a+3 地址处，应该这样写：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">memcpy(a + 3, a, 5*sizeof(int));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/baidu_35679960/article/details/80953973">memcpy使用时需要注意的地方</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】Linux目录结构</title>
      <link href="/2020/08/07/%E5%B5%8C%E5%85%A5%E5%BC%8F-Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>/2020/08/07/%E5%B5%8C%E5%85%A5%E5%BC%8F-Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/20180715222836494" alt="Linux 目录结构"></p><ul><li><strong>/usr：不是 user 的缩写，其实 usr 是 Unix Software Resource 的缩写，也就是 Unix 操作系统软件资源所放置的目录，而不是用户的数据啦。</strong>这点要注意。FHS 建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录；</li><li><strong>/tmp：这是让一般使用者或者是正在执行的程序暂时放置档案的地方。</strong>这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊。因为 FHS 甚至建议在开机时，应该要将 /tmp 下的资料都删除；</li><li><strong>/etc：系统主要的设定档几乎都放置在这个目录内，</strong>例如人员的帐号密码档、各种服务的启始档等等。一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有 root 有权力修改。FHS 建议不要放置可执行档（binary）在这个目录中。比较重要的档案有：/etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/ 等等。</li></ul><hr><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><blockquote><p>Linux 中的文件/目录权限设置命令是什么？</p></blockquote><p>解答：chmod</p><p>Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。</p><hr><p>参考：</p><ul><li><a href="https://www.cnblogs.com/silence-hust/p/4319415.html">Linux文件目录结构详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】内核态和用户态</title>
      <link href="/2020/08/07/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81/"/>
      <url>/2020/08/07/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h2><p>用户空间：是用户可以操作和访问的空间，这个空间通常存放我们<strong>用户自己写的数据</strong>等；</p><p>内核空间：是<strong>系统内核</strong>来操作的一块空间，这块空间里面存放系统内核的函数、接口等。</p><h2 id="内核空间与用户空间的通信方式"><a href="#内核空间与用户空间的通信方式" class="headerlink" title="内核空间与用户空间的通信方式"></a>内核空间与用户空间的通信方式</h2><p>Linux 下内核空间与用户空间进行通信的方式主要有 <strong>syscall</strong>(system call) 、<strong>procfs</strong>、<strong>ioctl</strong> 和 <strong>netlink</strong> 等。</p><ul><li><strong>syscall</strong>：一般情况下，<strong>用户进程是不能访问内核的</strong>，它既不能访问内核所在的内存空间，也不能调用内核中的函数。Linux 内核中设置了一组用于实现各种系统功能的子函数，用户可以通过调用他们访问 Linux 内核的数据和函数，这些系统调用接口（SCI）成为系统调用。</li><li><strong>procfs</strong>：是一种<strong>特殊的伪文件系统</strong>，是 Linux 内核信息的抽象文件接口，大量内核中的信息以及可调参数都被作为一个常规文件映射到一个目录树中，这样我们就可以简单直接的通过 echo 或 cat 这样的文件操作命令对系统信息进行查取。</li><li><strong>netlink</strong>：用户态应用使用标准的 socket API 就可以使用 netlink 提供的强大功能。</li><li><strong>ioctl</strong>：函数是<strong>文件结构中的一个属性分量</strong>，就是说如果你的驱动程序提供了对 ioctl 的支持，用户就可以在用户程序中使用 ioctl 函数控制设备的 I/O 通道。</li></ul><hr><p>Linux操作系统一般是通过<strong>软件中断</strong>从用户态切换到内核态。软件中断和中断（硬件中断）不同之处在于，它是通过软件指令触发而并非外设引发的中断，也就是说，又是编程人员开发出的一种异常（该异常为正常的异常）。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】ARM指令和Thumb指令</title>
      <link href="/2020/08/07/%E5%B5%8C%E5%85%A5%E5%BC%8F-ARM%E6%8C%87%E4%BB%A4%E5%92%8CThumb%E6%8C%87%E4%BB%A4/"/>
      <url>/2020/08/07/%E5%B5%8C%E5%85%A5%E5%BC%8F-ARM%E6%8C%87%E4%BB%A4%E5%92%8CThumb%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="ARM-指令和-Thumb-指令"><a href="#ARM-指令和-Thumb-指令" class="headerlink" title="ARM 指令和 Thumb 指令"></a>ARM 指令和 Thumb 指令</h2><p>在 ARM 的体系结构之中，可以工作在 3 中不同的工作状态:</p><ol><li><p><strong>ARM</strong> 状态：arm 处于 <strong>32</strong> 位指令状态</p></li><li><p><strong>Thumb</strong> 状态：arm 处于 <strong>16</strong> 位指令状态</p><p>Thumb-2 状态： 是 ARM7 版本 ARM 处理器所具有的新的状态，新的 Thumb-2 内核技术<strong>兼有 16 位及 32 位指令</strong>，实现了更高的性能，更有效的功耗及更少地占用内存。总的来说，感觉这个状态除了兼有ARM和Thumb的优点外，还在这两种状态上有所提升，优化。</p></li><li><p>调试状态：处理器停机时进入调试状态</p></li></ol><p>ARM 状态和 Thumb 状态可以直接通过某些命令进行切换。</p><h2 id="ARM-状态和-Thumb-状态切换"><a href="#ARM-状态和-Thumb-状态切换" class="headerlink" title="ARM 状态和 Thumb 状态切换"></a>ARM 状态和 Thumb 状态切换</h2><p>从 ARM 到 Thumb：LDR R0,=lable+1 BX R0</p><p>从 Thumb 到 ARM：LDR R0,=lable BX R0</p><p>处理器进行异常处理时，从异常向量地址开始，自动进入 ARM 状态。</p><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul><li>ARM 处理器复位后，开始执行代码时总是处于 <strong>ARM</strong> 状态；</li><li>Cortex-M3 只有 Thumb-2 状态和调试状态；</li><li>因为 Thumb-2 具有 16/32 位指令功能，所以有了 Thumb-2 就无需 Thumb 了；</li><li>因为 Thumb-2 具有 32 位指令功能，所以无需在 ARM 状态和 Thumb-2 状态之间切换了。</li></ul><hr><p>参考：</p><ul><li><a href="https://www.cnblogs.com/yygsj/p/5428500.html">ARM状态和THUMB状态</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言】static关键字、混合三目运算</title>
      <link href="/2020/08/06/C%E8%AF%AD%E8%A8%80-static%E5%85%B3%E9%94%AE%E5%AD%97-%E6%B7%B7%E5%90%88%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97/"/>
      <url>/2020/08/06/C%E8%AF%AD%E8%A8%80-static%E5%85%B3%E9%94%AE%E5%AD%97-%E6%B7%B7%E5%90%88%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="static用于声明静态变量"><a href="#static用于声明静态变量" class="headerlink" title="static用于声明静态变量"></a>static用于声明静态变量</h2><ul><li>全局静态变量</li><li>局部静态变量：存放在静态变量区</li><li>修饰静态函数：函数作用域仅限于本文件</li></ul><p>静态函数，在程序员协同工作时，可以防止变量、函数重名</p><hr><h3 id="有符号和无符号混合三目运算问题"><a href="#有符号和无符号混合三目运算问题" class="headerlink" title="有符号和无符号混合三目运算问题"></a>有符号和无符号混合三目运算问题</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">void fun(void)&#123;    unsigned int a &#x3D; 6;    int b &#x3D; -20;    int c;    (a+b &gt; 6) ? (c&#x3D;1) : (c&#x3D;0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当表达式中存在有符号类型和无符号类型时，所有的操作数都自动转换为无符号类型；因此-20变成了一个非常大的正整数。</p><p>表达式的结果为c = 1</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】TCP与UDP</title>
      <link href="/2020/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F-TCP%E4%B8%8EUDP/"/>
      <url>/2020/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F-TCP%E4%B8%8EUDP/</url>
      
        <content type="html"><![CDATA[<p>TCP/IP协议是一个协议簇。里面包括很多协议，包括TCP、IP、UDP等。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTE2MjA0MzM5NzU0" alt="TCP流程图"></p><p>TCP的三次握手和四次挥手，TCP使用面向连接的通信方式，大大提高了数据通信的可靠性，使发送数据端和接收端在数据正式传输前就有了交互。</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTE2MjEwNTIzNjQx" alt="UDP流程图"></p><h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><table><thead><tr><th>角度</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否连接</td><td>面向连接（发送数据前需要建立连接）</td><td>无连接（发送数据无需连接）</td></tr><tr><td>是否丢包重试</td><td>实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制</td><td>不会进行丢包重试，也不会纠正到达的顺序</td></tr><tr><td>模式</td><td>流模式（面向字节流）</td><td>数据报模式（面向报文）</td></tr><tr><td>对应关系</td><td>一对一</td><td>支持一对一、一对多、多对一、和多对多的交互通信</td></tr><tr><td>头部开销</td><td>最小20个字节</td><td>只有8字节</td></tr><tr><td>可靠性</td><td>全双工非常可靠、无差错、不丢失、不重复、且按序到达</td><td>不保证可靠交付，不保证顺序到达</td></tr><tr><td>拥塞控制</td><td>有控制</td><td>有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</td></tr><tr><td>资源需求</td><td>TCP程序结构复杂，较多</td><td>UDP程序结构简单，少</td></tr></tbody></table><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/u011957758/article/details/72353485">一看就懂系列之 超级详解TCP与UDP</a></li><li><a href="https://blog.csdn.net/sicofield/article/details/9708383">TCP的拥塞控制</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言】volatile关键字</title>
      <link href="/2020/08/05/C%E8%AF%AD%E8%A8%80-volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2020/08/05/C%E8%AF%AD%E8%A8%80-volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="volatile是易变，不稳定的意思"><a href="#volatile是易变，不稳定的意思" class="headerlink" title="volatile是易变，不稳定的意思"></a>volatile是易变，不稳定的意思</h2><p>volatile修变量可以被某些未知的因素而改变，未知的因素包括操作系统、硬件或其他线程等。每次使用都从<strong>内存重新装载内容</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#示例1#include &lt;studio.h&gt;int main (void)&#123;int i &#x3D; 10;    int a &#x3D; i;    int b &#x3D; i;    printf (&quot;i &#x3D; %d\n&quot;, b);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>i的值直接从寄存器中读取，a，b的值相等。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#示例2#include &lt;studio.h&gt;int main (void)&#123;volatile int i &#x3D; 10;    int a &#x3D; i;    int b &#x3D; i;    printf (&quot;i &#x3D; %d\n&quot;, b);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>i的值是随时可能发生变化的，所以a，b的值不一定相等。</p><h2 id="volatile的使用："><a href="#volatile的使用：" class="headerlink" title="volatile的使用："></a>volatile的使用：</h2><ol><li>并行设备的硬件寄存器（如：状态寄存器）</li><li>中断服务子程序中会访问到的非自动变量</li><li>多线程应用中被几个任务共享的变量</li></ol><hr><p>C语言编译过程中，volatile关键字和extern关键字分别在哪个阶段起作用？</p><p>volatile：编译阶段</p><p>extern：链接阶段</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言】源码到可执行文件过程</title>
      <link href="/2020/08/04/C%E8%AF%AD%E8%A8%80-%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/08/04/C%E8%AF%AD%E8%A8%80-%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>从文本到可执行文件一般需要4个过程：</p><table><thead><tr><th>执行过程</th><th>处理内容</th></tr></thead><tbody><tr><td>预编译阶段</td><td>主要处理源代码文件中的以“#”开头的预编译指令，生成<strong>预编译文件</strong>。</td></tr><tr><td>编译阶段</td><td>预编译文件转换为特定汇编代码，生成<strong>汇编文件</strong>。</td></tr><tr><td>汇编阶段</td><td>将汇编文件转换为机器码，生成<strong>可重定位目标文件</strong>。</td></tr><tr><td>链接阶段</td><td>将多个目标文件及所需要的库连接成最终的<strong>可执行目标文件</strong>。</td></tr></tbody></table><p><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/image-20200804140530964.png" alt="文本到可执行文件处理过程"></p><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/weixin_42060900/article/details/99229518">【机试题】2019.8.6大疆嵌入式笔试题B卷笔试题目总结</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言】const关键字</title>
      <link href="/2020/08/04/C%E8%AF%AD%E8%A8%80-const%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2020/08/04/C%E8%AF%AD%E8%A8%80-const%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<ul><li>const意味着<strong>常数</strong>。</li><li>const定义的变量，他的值不能被改变，在整个作用域中都保持固定</li><li>同宏定义一样，可以避免意义模糊的数字出现，同样可以很方便的进行参数的调整和修改</li><li>可以保护被修饰的东西，防止意外的修改，增强程序的<strong>健壮性</strong>。</li><li>const是通过编译器在<strong>编译的时候执行检查</strong>来确保实现的。</li></ul><h2 id="const与指针"><a href="#const与指针" class="headerlink" title="const与指针"></a>const与指针</h2><table><thead><tr><th>指针</th><th>含义</th></tr></thead><tbody><tr><td><code>const int a;</code></td><td>a是一个常整型数</td></tr><tr><td><code>int const a;</code></td><td>a是一个常整型数</td></tr><tr><td><code>const int *a;</code></td><td>a是一个指向常整型数的指针（数不可修改，指针可以修改）</td></tr><tr><td><code>int const *a;</code></td><td>a是一个指向整型数的常指针（数可修改，指针不可以修改）</td></tr><tr><td><code>const int *const a;</code></td><td>a是一个指向常整型数的常指针（数不可修改，指针不可以修改）</td></tr><tr><td><code>int const *const a;</code></td><td>a是一个指向常整型数的常指针（数不可修改，指针不可以修改）</td></tr></tbody></table><h2 id="const与函数"><a href="#const与函数" class="headerlink" title="const与函数"></a>const与函数</h2><p>const通常用在函数形参当中，如果形参是一个指针，为了<strong>防止在函数内部修改指针指向的数据</strong>。就可以用const来限制。比如在String的程序中就有很多const修饰形参的情况。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void StringCopy (char* strDestination, const char *strSource)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>const还可以表示该函数返回的一个常量，放在函数的返回值的位置，例如</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">const char * GetString(void);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在类成员函数的声明和定义之中，const放在函数的形参表之后，函数体之前，表示该函数的this指针是一个常量，不能修饰该对象的数据成员，例如</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void getId () const;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><p>下面这段程序的运行结果？</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int main ()&#123;    const int x &#x3D; 5;    const int *ptr;    ptr &#x3D; &amp;x;    printf(&quot;%d\n&quot;,x);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>编译出错</strong></p><p>x是常整型数，ptr是指向常整型的指针。<code>ptr = &amp;x;</code>，即<code>ptr = 10;</code>，违反了const的规则；const是通过编译器在编译的时候检查来实现的，所以编译报错。</p><hr><p>参考：</p><ul><li><a href="https://www.cnblogs.com/fengxing999/p/10248636.html">const修饰指针的三种效果</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言】动态分配堆内存</title>
      <link href="/2020/07/31/C%E8%AF%AD%E8%A8%80-%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%A0%86%E5%86%85%E5%AD%98/"/>
      <url>/2020/07/31/C%E8%AF%AD%E8%A8%80-%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%A0%86%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="动态分配堆内存"><a href="#动态分配堆内存" class="headerlink" title="动态分配堆内存"></a>动态分配堆内存</h2><p>在C语言中，内存分为四块存储区域，栈，堆，静态存储区，代码区。堆内存是一种在需要时申请，在不需要时释放的内存块，都是由程序员来完成的，今天我们来探讨一下动态分配堆内存的库函数，这些库函数包含在头文件&lt;stdlib.h&gt;中。</p><h2 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h2><p>开辟规定大小的堆内存空间，申请一块连续的指定大小的内存块区域以void*类型返回分配的内存区域地址。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main (void)&#123;    int *p1;    p1 &#x3D; (int *)malloc(sizeof(int) * 10);    printf(&quot;%p\n&quot;,p1);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成了40个字节大小未被初始化的内存空间。</p><h2 id="calloc函数"><a href="#calloc函数" class="headerlink" title="calloc函数"></a>calloc函数</h2><p>在内存的动态存储区中分配n个长度为size的连续空间，函数返回一个指向分配起始地址的指针；如果分配不成功，返回NULL。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main (void)&#123;    int *p1;    p1 &#x3D; (int *)calloc(10, sizeof(int));    printf(&quot;%p\n&quot;,p1);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码用calloc函数随机分配40个字节的存储空间，calloc函数开辟的40个字节的堆内存被初始化为0。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>写程序的时候多用<strong>malloc</strong>而少用calloc，因为calloc虽然对内存进行了初始化（全部初始化为0），但多了对内存的写零操作，效率会降低。</p><h2 id="realloc函数"><a href="#realloc函数" class="headerlink" title="realloc函数"></a>realloc函数</h2><p>重新分配内存大小。</p><ul><li>如果当前指针有足够的连续空间，则<strong>扩大</strong>mem_address指向的地址，并且将mem_address返回，</li><li>如果当前指针没有足够的连续空间，则按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address所指内存区域（注意：原来指针是自动释放，不需要使用free），同时返回新分配的内存区域的首地址。即<strong>重新分配存储器块的地址</strong>。</li></ul><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/MarcoAsensio/article/details/85937002">C语言中malloc，calloc，realloc等动态分配内存函数特点详解</a></li><li><a href="https://blog.csdn.net/csdn_kou/article/details/80499565">C语言malloc和calloc的区别</a></li><li><a href="https://www.cnblogs.com/stevenwuzheng/p/5484986.html">C语言中malloc()和calloc()函数用法 </a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言】作用域和生命周期</title>
      <link href="/2020/07/31/C%E8%AF%AD%E8%A8%80-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2020/07/31/C%E8%AF%AD%E8%A8%80-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="作用域和生命周期"><a href="#作用域和生命周期" class="headerlink" title="作用域和生命周期"></a>作用域和生命周期</h2><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>变量的作用域指变量能在代码什么地方可以被访问到。</p><table><thead><tr><th>变量类型</th><th>作用域</th></tr></thead><tbody><tr><td>全局变量</td><td>所有程序中的代码都能访问</td></tr><tr><td>静态全局变量</td><td>在同一个源文件中可以访问，不同源文件不可访问，也不能用extern来导入</td></tr><tr><td>局部变量</td><td>只能在函数内部访问</td></tr><tr><td>静态局部变量</td><td>只能函数内部访问</td></tr><tr><td>寄存器变量</td><td>只能在函数内部访问</td></tr></tbody></table><p>注：如果全局变量在一个源文件中定义，在另一个源文件中访问，需要用extern关键字导入。多线程访问全局变量注意安全问题。</p><h3 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h3><p>变量的生命周期是指变量在程序运行期间的有效时间</p><table><thead><tr><th>变量类型</th><th>生命周期</th></tr></thead><tbody><tr><td>全局变量</td><td>整个程序运行期间有效</td></tr><tr><td>静态全局变量</td><td>整个程序运行期间有效</td></tr><tr><td>局部变量</td><td>函数范围内或代码块范围内有效</td></tr><tr><td>静态局部变量</td><td>整个程序运行期间有效</td></tr><tr><td>寄存器变量</td><td>函数范围内或代码块范围内有效</td></tr></tbody></table><h2 id="static和extern"><a href="#static和extern" class="headerlink" title="static和extern"></a>static和extern</h2><h3 id="static修饰全局变量"><a href="#static修饰全局变量" class="headerlink" title="static修饰全局变量"></a>static修饰全局变量</h3><ul><li>表示这个全局变量只能在<strong>当前文件</strong>使用，不能在其他文件使用</li><li>在不同文件可以声明同名变量</li><li>修饰函数表示这是一个内部函数</li></ul><h3 id="static修饰局部变量"><a href="#static修饰局部变量" class="headerlink" title="static修饰局部变量"></a>static修饰局部变量</h3><ul><li>延长局部变量声明周期，从程序启动到程序结束，但是没有修改变量的作用域</li><li>定义变量的代码在整个程序运行期间就只<strong>执行一次</strong></li></ul><h3 id="extern修饰全局变量"><a href="#extern修饰全局变量" class="headerlink" title="extern修饰全局变量"></a>extern修饰全局变量</h3><ul><li>表示这个全局变量可以在<strong>其他文件</strong>使用</li><li>在不同文件不能声明同名变量</li><li>修饰函数表示这是一个外部函数</li></ul><h3 id="extern-不能修饰局部变量"><a href="#extern-不能修饰局部变量" class="headerlink" title="extern 不能修饰局部变量"></a><em>extern 不能修饰局部变量</em></h3><p><strong>注：全局变量、静态全局变量、静态局部变量的声明周期相同，都是直到程序结束才被释放</strong></p><hr><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><blockquote><p>分析下列程序中每个变量的存储位置，作用域，与生命周期 </p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a &#x3D; 0;char *p1;static int x &#x3D; 10;void func(void)&#123; int b; char s[] &#x3D; &quot;123&quot;; char *p2; char *p3 &#x3D; &quot;hello,world&quot;; static int c &#x3D; 0; register int i &#x3D; 0; p1 &#x3D; (char *)malloc(128); p2 &#x3D; (char *)malloc(256); free(p1); free(p2);&#125;int main(void)&#123; func(); printf(&quot;hello,world\n&quot;); return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a &#x3D; 0;&#x2F;&#x2F;全局变量,初始化char *p1;&#x2F;&#x2F;全局变量,static int x &#x3D; 10;&#x2F;&#x2F;全局变量,初始化void func(void)&#123;    int b;&#x2F;&#x2F;局部变量    char s[] &#x3D; &quot;123&quot;;&#x2F;&#x2F;s为局部变量,&quot;123&quot;为常量,初始化    char *p2;&#x2F;&#x2F;局部变量    char *p3 &#x3D; &quot;hello,world&quot;;&#x2F;&#x2F;p3为局部变量,&quot;hello,world&quot;为常量,初始化    static int c &#x3D; 0;&#x2F;&#x2F;局部静态变量,初始化    register int i &#x3D; 0;&#x2F;&#x2F;寄存器变量,初始化    p1 &#x3D; (char *)malloc(128);&#x2F;&#x2F;p1指向堆上的内存,直到free    p2 &#x3D; (char *)malloc(256);&#x2F;&#x2F;p2指向堆上的内存,直到free    free(p1);    free(p2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>变量或常量</th><th>存储空间</th><th>作用域</th><th>生命周期</th></tr></thead><tbody><tr><td>a</td><td>静态区（data.）</td><td>整个工程,extern int a;</td><td>整个程序结束</td></tr><tr><td>p1</td><td>静态区（bbs.），指向的内存在堆上</td><td>整个工程,extern char *p1;</td><td>整个程序结束，指向的内存需要free释放。</td></tr><tr><td>x</td><td>静态区（data.）</td><td>当前文件</td><td>整个程序结束</td></tr><tr><td>b</td><td>栈</td><td>main函数</td><td>main函数结束</td></tr><tr><td>s</td><td>栈</td><td>main函数</td><td>main函数结束</td></tr><tr><td>p2</td><td>栈，指向的内存在堆上</td><td>main函数</td><td>main函数结束，指向的内存需要free释放</td></tr><tr><td>p3</td><td>栈</td><td>main函数</td><td>main函数结束</td></tr><tr><td>c（参考demo/static）</td><td>静态区（data.）</td><td>main函数</td><td>整个程序结束</td></tr><tr><td>i</td><td>可能是寄存器或栈</td><td>main函数</td><td>main函数结束</td></tr><tr><td>“hello,world”,”123”</td><td>静态区（data.）</td><td></td><td>整个程序结束</td></tr></tbody></table><hr><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/ce19ec49511c">static extern 局部变量 全局变量 生命周期 作用域</a></li><li><a href="https://blog.csdn.net/weixin_42528287/article/details/85783662">变量的类型、作用域、存储空间、生命周期</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言】数据存储结构</title>
      <link href="/2020/07/31/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
      <url>/2020/07/31/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>可执行程序（没有调用内存，没有运行时），内存结构分为：</p><ul><li>代码区</li><li>数据区</li><li>未初始化数据区（BSS区）</li></ul><p>可执行文件运行时有多处两个内存区域：</p><ul><li>堆区</li><li>栈区</li></ul><p><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/20190812222411723." alt="程序内存结构"></p><p><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/20190812173831493." alt="内存结构"></p><hr><h2 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h2><h3 id="代码区（text区）"><a href="#代码区（text区）" class="headerlink" title="代码区（text区）"></a>代码区（text区）</h3><p>存放数据：存放程序<strong>执行代码</strong>，也有可能包含一些只读的常数变量。</p><p>这部分区域的内存大小在程序执行前就已经确定，并且内存区域属于<strong>只读</strong>。数据保存在目标文件中。</p><h3 id="数据区（data区）"><a href="#数据区（data区）" class="headerlink" title="数据区（data区）"></a>数据区（data区）</h3><p>存放数据：在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据。</p><p>data区在编译时已经为数据分配了空间，数据保存在目标文件中。</p><p>data区属于静态分配，程序结束后静态变量资源由系统自动释放。</p><h3 id="未初始化数据区（BSS区）"><a href="#未初始化数据区（BSS区）" class="headerlink" title="未初始化数据区（BSS区）"></a>未初始化数据区（BSS区）</h3><p>存放数据：程序中未初始化的全局变量和静态变量。</p><p>BBS区内容不存放在磁盘上的程序文件中，不占用可执行文件的大小，它是由链接器来获取内存的；原因是内核在程序运行前将他们都置为0。</p><p>BBS区属于静态分配，程序结束后静态变量资源由系统自动释放。</p><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>堆允许程序在运行时动态分配内存，一般由程序员申请释放；</p><p>堆是由低地址位向高地址位增长，采用链式储存结构，位于BSS与栈中间的地址区域；</p><p>频繁的进行malloc/free会造成内存空间的不连续，产生碎片；</p><p>当申请对空间时库函数是按照一定的算法来搜索可用的足够大的空间。因此堆的效率比栈要地的多。</p><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>由编译器自动分配释放，存放函数的参数值、局部变量等值；每当一个函数被调用时，该函数的返回类型和一些调用信息被存放到栈中；然后这个被调用的函数再为它的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。</p><p>栈区是由高地址位向低地址为增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出。一般Windows是1M ~ 8M不等，一般Linux是1M ~ 16M不等。</p><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/weixin_42528287/article/details/85783662">变量的类型、作用域、存储空间、生命周期</a></li><li><a href="https://blog.csdn.net/u011616739/article/details/61621815">C语言 内存管理</a></li><li><a href="https://blog.csdn.net/weixin_42060900/article/details/99229518">【机试题】2019.8.6大疆嵌入式笔试题B卷笔试题目总结</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】05替换空格</title>
      <link href="/2020/07/29/%E7%AE%97%E6%B3%95-05%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>/2020/07/29/%E7%AE%97%E6%B3%95-05%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 </p><blockquote><p>示例 1：</p><p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p></blockquote><p>限制：0 &lt;= s 的长度 &lt;= 10000</p></blockquote><h3 id="方法一：创造新的字符串，在新的字符串上面进行替换。"><a href="#方法一：创造新的字符串，在新的字符串上面进行替换。" class="headerlink" title="方法一：创造新的字符串，在新的字符串上面进行替换。"></a>方法一：创造新的字符串，在新的字符串上面进行替换。</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define ERROR -1char* replaceSpace(char* s)&#123;    char *A &#x3D; calloc(strlen(s)*3+1,sizeof(char));&#x2F;&#x2F;strlen(s)*3+1  全为空格‘ ’-&gt;‘%20’+‘\0’    int i &#x3D; 0;&#x2F;&#x2F;两个指针i，k    int k &#x3D; 0;    if(s &#x3D;&#x3D; NULL)    &#123;        return ERROR;    &#125;    while(s[i]!&#x3D;&#39;\0&#39;)    &#123;                if(s[i] &#x3D;&#x3D; &#39; &#39;)        &#123;            A[k++] &#x3D; &#39;%&#39;;&#x2F;&#x2F;k++，替换            A[k++] &#x3D; &#39;2&#39;;            A[k++] &#x3D; &#39;0&#39;;            i++;        &#125;        else        &#123;            A[k++] &#x3D; s[i];            i++;        &#125;    &#125;    return A;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="方法二：不创造新的字符串，在原有的字符串上面进行替换。"><a href="#方法二：不创造新的字符串，在原有的字符串上面进行替换。" class="headerlink" title="方法二：不创造新的字符串，在原有的字符串上面进行替换。"></a>方法二：不创造新的字符串，在原有的字符串上面进行替换。</h3><ol><li><p>从头到尾扫描字符串，每次遇到空格的时候进行替换。替换时把后面的所有字符都往后移动2个字节。</p></li><li><p>先遍历一遍字符串，计算出字符串中的空格数。再从字符串的后面开始复制和替换，指针p1指向原始字符串的末尾，p2指向替换后的字符串的末尾。</p><p><strong>从后往前替换，节省了字符后移的步骤。</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言】宏定义</title>
      <link href="/2020/07/28/C%E8%AF%AD%E8%A8%80-%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
      <url>/2020/07/28/C%E8%AF%AD%E8%A8%80-%E5%AE%8F%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h2 id="实例1："><a href="#实例1：" class="headerlink" title="实例1："></a>实例1：</h2><blockquote><p>宏定义计算问题</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define PRODUCT (x) (x*x)int main()&#123; int a,b &#x3D; 3; a &#x3D; PRODUCT(b+2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>求a的值：</p></blockquote><p>结果为：<code>a = b+2*b+2=3+2*3+2=11</code></p><h2 id="实例2："><a href="#实例2：" class="headerlink" title="实例2："></a>实例2：</h2><blockquote><p>描述下面XXX这个宏的作用。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define offsetof(TYPE,MEMBER) ((size_t)&amp;((TYPE*)0)-&gt;MEMBER)#define XXX(ptr,type,member)(&#123;\const typeof(((type*)0)-&gt;member) *__mpter&#x3D;(ptr);\(type*)((type*)__mpter - offsetof(type,member));&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><strong>第一个宏：</strong></p><p><code>#define offsetof(TYPE,MEMBER) ((size_t)&amp;((TYPE*)0)-&gt;MEMBER)</code></p><ul><li><code>(TYPE*)0</code>，将0强制转换为TYPE类型的指针，并且指向了0地址空间。</li><li><code>(TYPE*)0)-&gt;MEMBER</code>，指向结构体中的成员</li><li><code>&amp;((TYPE*)0)-&gt;MEMBER</code>，获取成员在结构体中的位置，因为其实位置为0，所以获取的地址即为实际的偏移地址。</li><li><code>(size_t)&amp;((TYPE*)0)-&gt;MEMBER</code>，将偏移地址强制转换为size_t，即unsigned int。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">(TYPE*)0&#x3D;&gt;p &#x3D; (TYPE*)0(TYPE*)0)-&gt;MEMBER&#x3D;&gt;p-&gt;MEMBER&amp;((TYPE*)0)-&gt;MEMBER)&#x3D;&gt;&amp;(p-&gt;MEMBER)&#x2F;&#x2F;成员MEMBER的地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>第二个宏：</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define XXX(ptr,type,member)(&#123;\const typeof(((type*)0)-&gt;member) *__mpter&#x3D;(ptr);\(type*)((type*)__mpter - offsetof(type,member));&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>(&#123; &#125;)</code>的语法形式是GNU C编译器的语法扩展，与逗号表达式类似，表达式结果为最后一个语句的值。</li><li><code>typeof</code>主要用于宏定义之中，可以使用typeof关键字来引用宏参数的类型。</li><li><code>typeof(((type*)0)-&gt;member)</code>，引用type结构体的member成员的数据类型。</li><li><code>const typeof(((type*)0)-&gt;member) *__mpter=(ptr);</code>，定义一个与type结构体的member成员相同的类型的指针变量<code>__mpter</code>，而且将<code>ptr</code>赋值给它。</li><li><code>offsetof(type,member)</code>，获取member成员在type结构中的偏移量。</li><li><code>(type*)((type*)__mpter - offsetof(type,member));</code>，将<code>__mpter</code>减去偏移量，就得到了这个结构变量的地址了（指针）。</li></ul><p><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/20180207165907690" alt="结构变量的地址"></p><p>ptr是指向正被使用的某类型变量指针；</p><p>type是包含ptr指向的变量类型的结构类型；</p><p>member是type结构体中的成员，类型与ptr指向的变量类型一样；</p><p>宏定义的功能是：计算返回包含ptr指向的变量所在的type类型结构变量的指针。</p><p>参考：<a href="https://blog.csdn.net/feiyanaffection/article/details/79282562">老生常谈的Linux内核中常用的两个宏定义</a></p><h2 id="实例3："><a href="#实例3：" class="headerlink" title="实例3："></a>实例3：</h2><blockquote><p>用C语言字节编写一下四个宏</p><p>ALGN_DOWN(x, a)将数值x按照a的整数倍向下取整，例如ALGN_DOWN(65,3) = 63；</p><p>ALGN_UP(x, a)将数值x按照a的整数倍向上取整，例如ALGN_UP(65,3) = 66；</p><p>ALGN_2N_DOWN(x, a)将数值x按照a的整数倍向下取整，a是2的n次幂，例如ALGN_2N_DOWN(65,4) = 64；</p><p>ALGN_2N_UP(x, a)将数值x按照a的整数倍向上取整，a是2的n次幂，例如ALGN_2N_UP(65,4) = 68。</p></blockquote><p>设条件为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int x; int a &#x3D; 8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>将数值x按照a的整数倍向下取整，a是2的n次幂:</strong></p><p>对齐掩码a_mask = 11111 11111 11111 11111 11111 11110 00，即 ~(a- 1)</p><p>对齐掩码a_mask与a进行”与运算”就可以得到，将数值x按照a的整数倍向下取整，a是2的n次幂。</p><p><code>#ALGN_2N_DOWN(x, a)        (x &amp; ([~(a-1)]) )</code></p><p><strong>将数值x按照a的整数倍向上取整，a是2的n次幂</strong></p><p>如果要求出比x大的是不是需要加上a就可以了？可是如果x本身就是a的倍数，这样加a不就错了吗？</p><p>所以在x基础上加上(a - 1)，然后与a的对齐掩码进行与运算。</p><p><code>#ALGN_2N_UP(x, a)     ((x+a-1) &amp; (~ (a-1)))</code></p><p>实例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">x&#x3D;0, a&#x3D;8, 则ALGN_2N_DOWN(x,a)&#x3D;0, ALGN_2N_UP(x,a)&#x3D;0.x&#x3D;6, a&#x3D;8, 则ALGN_2N_DOWN(x,a)&#x3D;0, ALGN_2N_UP(x,a)&#x3D;8.x&#x3D;8, a&#x3D;8, 则ALGN_2N_DOWN(x,a)&#x3D;8, ALGN_2N_UP(x,a)&#x3D;8.x&#x3D;14, a&#x3D;8,则ALGN_2N_DOWN(x,a)&#x3D;8, ALGN_2N_UP(x,a)&#x3D;16.注:a应当为2的n次方, 即2, 4, 8, 16, 32, 64, 128, 256, 1024, 2048, 4096 ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考：<a href="https://blog.csdn.net/heybeaman/article/details/80491871">内核宏ALIGN的含义</a></p><h2 id="实例4"><a href="#实例4" class="headerlink" title="实例4"></a>实例4</h2><blockquote><p>用预处理指令#define声明一个常数，用以表示1年中有多少秒（忽略闰年问题）</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一年的秒数为31536000，16位的int型将会溢出，因此要使用长整型符号L</p><h2 id="实例5"><a href="#实例5" class="headerlink" title="实例5"></a>实例5</h2><blockquote><p>写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define MIN(A,B) ((A)&lt;&#x3D;(B)?(A):(B))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>容易错的地方：宏中间要小心地把参数用括号括起来。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】哈佛结构和冯诺依曼结构</title>
      <link href="/2020/07/27/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%E5%92%8C%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84/"/>
      <url>/2020/07/27/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%E5%92%8C%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="哈佛结构和冯诺依曼结构定义"><a href="#哈佛结构和冯诺依曼结构定义" class="headerlink" title="哈佛结构和冯诺依曼结构定义"></a>哈佛结构和冯诺依曼结构定义</h2><p>编程时程序代码被分为两大部分</p><ol><li>逻辑代码部分：程序编写完成后，就不需要对其进行修改了的；</li><li>定义变量部分：程序别写完成后，会随着程序的运行不断变化的内容。</li></ol><p>哈佛结构和冯诺依曼结构就是对这两部分代码的<strong>储存方式的区别</strong>。</p><h2 id="哈佛结构"><a href="#哈佛结构" class="headerlink" title="哈佛结构"></a>哈佛结构</h2><p><strong>程序指令储存器和数据储存器分开的储存结构。</strong></p><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/20180331225849539" alt="哈佛结构" style="zoom: 50%;" /><p>数据和指令的储存可以同时进行，可以使指令和数据有不同的数据宽度，哈佛结构有较高的执行效率。</p><p>预取指对指令顺序执行程序代码执行效率高，<strong>适合任务单调但需要高速率执行效率的CPU</strong>，如ARM、DSP。但总线多，成本高，对外设要求高。</p><h2 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h2><p><strong>是将程序指令储存器和数据储存器合并在一起的的储存结构。</strong></p><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/20180331225814322" alt="冯诺依曼结构" style="zoom:50%;" /><p>冯洛伊曼结构是将逻辑代码和变量统一储存在内存当中，他们之间一般是按照代码的执行顺序依次储存。冯洛伊曼结构可以充分的利用有限的内存空间。并且会使CPU对程序的执行十分的方便，不用来回的跑。</p><p>数据区和指令区共用memory，方便数据区和指令区灵活调整，如果程序频繁的切换，可以提高memory的利用率。总线简单，成本低，对外设要求低。<strong>适合PC这样多任务多软件的CPU</strong>。</p><h2 id="改进型哈佛结构："><a href="#改进型哈佛结构：" class="headerlink" title="改进型哈佛结构："></a>改进型哈佛结构：</h2><p>使用两个不同的存储器，程序存储器和数据存储器；使用两根总线，把两个存储器的2条地址总线和2条数据总线进行了合并；即<strong>原来哈佛结构需要４条不同的总线，改进后只需要两2条总线。</strong></p><p>使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存，以便实现并行处理；具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块（程序存储模块和数据存储模块），公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输；两条总线由程序存储器和数据存储器分时共用。</p><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/20180331225943123" alt="改进型哈佛结构" style="zoom:50%;" /><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/u014470361/article/details/79774331">什么是冯诺依曼结构、哈佛结构、改进型哈佛结构？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】通信总线</title>
      <link href="/2020/07/27/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BA%BF/"/>
      <url>/2020/07/27/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="总线的分类："><a href="#总线的分类：" class="headerlink" title="总线的分类："></a>总线的分类：</h3><ol><li><p>总线按功能和规范可分为五大类型：数据总线、地址总线、控制总线、扩展总线及局部总线。</p><p>数据总线、地址总线和控制总线也统称为系统总线，即通常意义上所说的总线。常见的数据总线为ISA、EISA、VESA、PCI等。</p></li></ol><ol start="2"><li><p>按照传输数据的方式划分，可以分为串行总线和并行总线。</p><p>串行总线中，二进制数据逐位通过一根数据线发送到目的器件；并行总线的数据线通常超过2根。常见的串行总线有S<a href="http://www.elecfans.com/tags/pi/">PI</a>、<a href="http://www.elecfans.com/tags/i2c/">I2C</a>、<a href="http://www.elecfans.com/tags/usb/">USB</a>及<a href="http://www.elecfans.com/tags/rs/">RS</a>232等。</p></li><li><p>按照<a href="http://www.elecfans.com/tags/%E6%97%B6%E9%92%9F/">时钟</a>信号是否独立，可以分为同步总线和异步总线。</p><p>同步总线的时钟信号独立于数据，而异步总线的时钟信号是从数据中提取出来的。SPI、I2C是同步串行总线，RS232采用异步串行总线。</p></li></ol><h3 id="常用总线："><a href="#常用总线：" class="headerlink" title="常用总线："></a>常用总线：</h3><table><thead><tr><th>总线接口</th><th>串/并</th><th>同步/异步</th><th>速率</th><th>工作方式</th><th>用线</th><th>总线拓扑结构</th><th>通信距离</th></tr></thead><tbody><tr><td>UART</td><td>串</td><td>异步</td><td>慢（波特率）</td><td>全双工</td><td>2线（RX、TX）</td><td>RS485支持总线式、星形、树形</td><td>远（最远1200m）</td></tr><tr><td>I2C</td><td>串</td><td>同步</td><td>慢</td><td>半双工</td><td>2线（SDA、SCL）</td><td>总线型（特殊的树形）</td><td>近</td></tr><tr><td>SPI</td><td>串</td><td>同步</td><td>快</td><td>全双工</td><td>3线或4线（SCLK、SIMO、SOMI、SS(片选)）</td><td>环形</td><td>远</td></tr><tr><td>USB</td><td>串</td><td>同步</td><td>快</td><td>半双工</td><td>4线（Vbus(5V)、GND、D+、D-(3.3V)）</td><td>星形</td><td>近</td></tr></tbody></table><p>在SOC中常常用作于对外设寄存器配置的总线是：I2C，SPI</p><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/aidelong/article/details/83146340">总线类型最全汇总</a></li><li><a href="http://wangboxyk.cn/post/Zongxian-Bus-QPI-Memory.html">总线概述及常见总线</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言】大小端问题</title>
      <link href="/2020/07/26/C%E8%AF%AD%E8%A8%80-%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/26/C%E8%AF%AD%E8%A8%80-%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="何为大小端问题？"><a href="#何为大小端问题？" class="headerlink" title="何为大小端问题？"></a>何为大小端问题？</h2><p>大端模式（BE big-endian）：数据的低位保存在内存的高地址中，而数据的高位保存在内存的低地址中<strong>（低对高，高对低）</strong></p><p>小端模式（LE little-endian）：数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中<strong>（低对低，高对高）</strong></p><blockquote><p>实例：</p><p>A=0x12345678存入地址1000H~1003H中</p><p>小端模式：1000H=78,1001H=56,1002H=34,1003H=12</p><p>大端模式：1000H=12,1001H=34,1002H=56,1003H=78</p></blockquote><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/b2de9c82d158ccbf4ea6fbf1c413933bb0354137.jpeg" alt="大小端数据储存示意" style="zoom:50%;" /><h2 id="区分大小端"><a href="#区分大小端" class="headerlink" title="区分大小端"></a>区分大小端</h2><ol><li><h3 id="利用指针来区分大小端"><a href="#利用指针来区分大小端" class="headerlink" title="利用指针来区分大小端"></a>利用指针来区分大小端</h3></li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">void Judge_duan()&#123;int a &#x3D; 1;  &#x2F;&#x2F;定义为1是为了方便 如果你喜欢你可以随意，            &#x2F;&#x2F;只要你能搞清楚 例如：0x11223344; char *p &#x3D; (char *)&amp;a;&#x2F;&#x2F;在这里将整形a的地址转化为char*；                     &#x2F;&#x2F;方便后面取一个字节内容 if(*p &#x3D;&#x3D; 1)&#x2F;&#x2F;在这里解引用了p的一个字节的内容与1进行比较；printf(&quot;小端\n&quot;);elseprintf(&quot;大端\n&quot;); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/20160426194551009" alt="利用指针来区分大小端" style="zoom: 67%;" /><ol start="2"><li><h3 id="Linux操作系统的源码中大小端的判断"><a href="#Linux操作系统的源码中大小端的判断" class="headerlink" title="Linux操作系统的源码中大小端的判断"></a>Linux操作系统的源码中大小端的判断</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">static union&#123;    char c[4];    unsigned long mylong;&#125;endian_test &#x3D; &#123;&#123;&#39;l&#39;,&#39;?&#39;,&#39;?&#39;,&#39;b&#39;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这是利用了联合体union的存放顺序是所有成员都从低地址开始存放的特性。由于联合体的各个成员共用内存，并同时只有一个成员获得该块地址的读取使用权。如果结果‘l’为小端模式，结果是‘b’为大端模式。</p></li></ol><ol start="3"><li><h3 id="利用联合体来检测大小端"><a href="#利用联合体来检测大小端" class="headerlink" title="利用联合体来检测大小端"></a>利用联合体来检测大小端</h3></li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;* 利用联合体来检测大小端 *&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; void Judge_duan(void)&#123;union t&#123;         int i;         char c;&#125; t1;     t1.i &#x3D; 1;     if(t1.c &#x3D;&#x3D; 1) printf(&quot;小端\n&quot;); else     printf(&quot;大端\n&quot;);&#125; int main()&#123;Judge_duan();&#x2F;&#x2F;在这里我们封装成一个函数，可以有参数和返回值也可以不需要system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="大小端的转换"><a href="#大小端的转换" class="headerlink" title="大小端的转换"></a>大小端的转换</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">int endian_convert(int t)&#123;    int result &#x3D; 0;    int i;        for(i &#x3D; 0; i &lt; sizeof(t); i++)    &#123;        result &lt;&lt;&#x3D; 8;        result |&#x3D; (t &amp; 0xff);        t &gt;&gt;&#x3D; 8;    &#125;    return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>参考：<a href="https://blog.csdn.net/bitboss/article/details/51247869">关于机器大小端的判定</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言】struct与union内存对齐</title>
      <link href="/2020/07/26/C%E8%AF%AD%E8%A8%80-struct%E4%B8%8Eunion%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
      <url>/2020/07/26/C%E8%AF%AD%E8%A8%80-struct%E4%B8%8Eunion%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="数据内存对齐"><a href="#数据内存对齐" class="headerlink" title="数据内存对齐"></a>数据内存对齐</h1><h3 id="内存对齐的作用："><a href="#内存对齐的作用：" class="headerlink" title="内存对齐的作用："></a>内存对齐的作用：</h3><ol><li><p>平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p></li><li><p>性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要做两次内存访问；而对齐的内存访问只需要依次访问。</p></li></ol><h3 id="不同平台数据类型占用字节表："><a href="#不同平台数据类型占用字节表：" class="headerlink" title="不同平台数据类型占用字节表："></a>不同平台数据类型占用字节表：</h3><table><thead><tr><th>数据类型</th><th>32位</th><th>64位</th><th>备注</th></tr></thead><tbody><tr><td>char</td><td>1</td><td>1</td><td></td></tr><tr><td>short</td><td>2</td><td>2</td><td></td></tr><tr><td>int</td><td>4</td><td>4</td><td></td></tr><tr><td>long</td><td>4</td><td>8</td><td>32位于64位不同</td></tr><tr><td>float</td><td>4</td><td>4</td><td></td></tr><tr><td>char*</td><td>4</td><td>8</td><td>其他类型指针也是如此</td></tr><tr><td>long long</td><td>8</td><td>8</td><td></td></tr><tr><td>double</td><td>8</td><td>8</td><td></td></tr><tr><td>long double</td><td>10/12</td><td>10/16</td><td>有效字节10字节，为了内存对齐实际分配：32位12字节，64位16字节</td></tr></tbody></table><h2 id="结构体（struct）"><a href="#结构体（struct）" class="headerlink" title="结构体（struct）"></a>结构体（struct）</h2><p>结构体（struct）各成员各自拥有自己的内存，各自使用互不干涉，同时存在的，遵循内存对齐原则。</p><h3 id="struct内存对齐规则："><a href="#struct内存对齐规则：" class="headerlink" title="struct内存对齐规则："></a>struct内存对齐规则：</h3><ol><li>结构体变量的<strong>起始地址</strong>能够被其最宽的成员大小整除</li><li>结构体每个成员相对于<strong>起始地址的偏移</strong>能够被其<strong>自身大小整除</strong>，如果不能则在<strong>前一个成员后面</strong>补充字节</li><li>结构体总体大小能够<strong>被最宽的成员的大小</strong>整除，如不能则在<strong>后面</strong>补充字节</li><li>程序中有<code>#pragma pack(n)</code>预编译指令，所有成员对齐以<strong>n字节为准</strong>（即偏移量是n的整数倍），不再考虑当前类型以及最大结构体类型。</li></ol><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;64位struct C&#123;    double t;&#x2F;&#x2F;8    char b;&#x2F;&#x2F;1    int a;&#x2F;&#x2F;4    short c;&#x2F;&#x2F;2&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>t占8个字节，是b的1个字节的整数倍，不需要补充字节；</p><p>b占1个字节，不是a的4个字节的整数倍，所以b后面需要加3个补充字节；</p><p>a占4个字节，是c的2个字节的整数倍，不需要补充字节；</p><p>c占2个字节，字节数为5+1+3+4+2=18；</p><p>总字节数要为double类型所占8字节的整数倍；所以c后面增加6个补充字节。</p><p>所以sizeof（C）=24；</p><hr><h3 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#pragma pack(1)struct fun&#123;    int i;&#x2F;&#x2F;4    double d;&#x2F;&#x2F;8    char c; &#x2F;&#x2F;1&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为程序中有<code>#pragma pack(1)</code>预编译命令，所谓所占字节为1字节的整数倍。</p><p>总字节数为4+8+1=13</p><p>sizeof（fun）=13；</p><hr><h2 id="联合体（union）"><a href="#联合体（union）" class="headerlink" title="联合体（union）"></a>联合体（union）</h2><p>联合体（union）各自成员共用一块内存空间，并且同时只有一个成员可以得到这这块内存的使用权（对该内存的读写），各变量共用一个内存首地址。</p><h3 id="union内存对齐规则："><a href="#union内存对齐规则：" class="headerlink" title="union内存对齐规则："></a>union内存对齐规则：</h3><ol><li>找到<strong>占用字节最多</strong>的成员</li><li>union的字节数必须是占用字节最多的成员的的字节的倍数，而且需要能够容纳其他的成员。</li></ol><p>实例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef union&#123;    long i;&#x2F;&#x2F;8    int k[5];&#x2F;&#x2F;4*5    char c;&#x2F;&#x2F;1&#125;D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>long为占字节最多的数据类型，占8个字节；所以该union字节数为8的整数倍；成员k占字节数为4*5=20。所以该union占字节数为24个字节。</p><hr><h2 id="更复杂的实例："><a href="#更复杂的实例：" class="headerlink" title="更复杂的实例："></a>更复杂的实例：</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct BU&#123;    int number;             &#x2F;&#x2F;4字节    union UBffer    &#123;        char buffer[13];    &#x2F;&#x2F;填充3字节，该成员占16字节空间        int number;    &#125;ubuf;    int aa;                 &#x2F;&#x2F;占4字节空间,当前偏移量已补齐为20    double dou;             &#x2F;&#x2F;占8字节空间&#125;bu;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sizeof(BU) = 4 + 13 + 3(补齐) + 4 + 8 = 32，分析方法类似，在计算aa的偏移量时，我们可以肯定的是一定是int类型的整数倍，由于不作任何缓冲补齐的情况下，number + buffer = 17字节，为了符合规则1，需要填充3个字节。</p><p>结构体BU稍微变换下aa和dou成员顺序，则结果就大不相同:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct BC&#123;    int number;             &#x2F;&#x2F;4字节    union UBffer    &#123;        char buffer[13];    &#x2F;&#x2F;填充7字节，该成员占20字节空间        int number;    &#125;ubuf;    double dou;             &#x2F;&#x2F;占8字节空间，当前偏移量已补齐为24    int aa;                 &#x2F;&#x2F;占4字节空间，当前占用空间36字节，最大double类型，还需要根据规则2补齐&#125;bu;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时sizeof(BC) = 4 + 13 + 7(规则1补齐) + 8 + 4 + 4(规则2补齐) = 40 (8的整数倍)</p><hr><p><code>__attribute__ ((__packed__))</code> 关键字，该关键字的作用：可以让结构体，按照紧凑排列的方式，占用内存。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;iostream&gt; using namespace std; struct test1 &#123;    char c;    int i;&#125;; struct __attribute__ ((__packed__)) test2 &#123;    char c;    int i;&#125;; int main()&#123;    cout &lt;&lt; &quot;size of test1:&quot; &lt;&lt; sizeof(struct test1) &lt;&lt; endl;    cout &lt;&lt; &quot;size of test2:&quot; &lt;&lt; sizeof(struct test2) &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：<br>sizeof (test1) = 8<br>sizeof (test2) = 5</p><hr><p>参考：</p><ul><li><a href="https://levphy.github.io/2017/03/23/memory-alignment.html">https://levphy.github.io/2017/03/23/memory-alignment.html</a></li><li><a href="https://blog.csdn.net/genzld/article/details/99744350"><strong>attribute</strong> ((<strong>packed</strong>)) 关键字</a></li></ul><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><ol><li><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3></li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a[5] &#x3D; &#123;1,2,3,4,5&#125;;sizeof(a) &#x3D; 20&#x2F;&#x2F;数组a占用的内存空间sizeof(*a) &#x3D; 4&#x2F;&#x2F;指向的int类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3></li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">char *p &#x3D; &quot;abcdefghijk&quot;;sizeof(p) &#x3D; 4&#x2F;&#x2F;指针占用4个字节的空间（32位机）sizeof(*p) &#x3D; 1&#x2F;&#x2F;指向的char类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言】*运算符和&amp;运算符、二维数组和指针</title>
      <link href="/2020/07/24/C%E8%AF%AD%E8%A8%80-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/"/>
      <url>/2020/07/24/C%E8%AF%AD%E8%A8%80-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h3 id="间接运算符和-amp-取址运算符"><a href="#间接运算符和-amp-取址运算符" class="headerlink" title="*间接运算符和&amp;取址运算符"></a>*间接运算符和&amp;取址运算符</h3><p>变量a本质上代表一个存储单元；CPU通过该存储单元的地址访问该存储单元中的数据。所以a本来代表两个值：存储单元的地址和储单元中的数据。即：    </p><ul><li><code>a</code>表示a对应的存储单元中的数据 </li><li><code>&amp;a</code>表示a对应的存储单元的地址 </li><li><code>*a</code>表示另一个存储单元中的数据 </li></ul><p><strong>声明</strong></p><p><code>int a</code>        a中存储的是一个整数数值，通过a可以访问这个数值</p><p><code>int *a</code>        a中存储的是一个存储单元的地址，而该存储单元中存储的数据是一个整数数值；通过<code>*a</code>可以访问这个数值。</p><p><code>int** a</code>        a中存储的是一个存储单元的地址；而该存储单元中存储的数据是另外一个存储单元的地址，这个存储单元中存储的是整数数值。</p><p>在C语言里地址叫指针。还有，数组本质上其实也是指针，即：<code>*a</code> 等同于 a[]。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a &#x3D; 10;int *b &#x3D; &amp;a;&#x2F;&#x2F;指针b指向a的地址printf(&quot;%d\n&quot;, a );&#x2F;&#x2F;a的数据值printf(&quot;%d\n&quot;, &amp;a);&#x2F;&#x2F;a的地址值printf(&quot;%d\n&quot;, b );&#x2F;&#x2F;指针b的值，即指针b指向的a的地址值printf(&quot;%d\n&quot;, *b);&#x2F;&#x2F;指针b指向的a的数据值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结果为：</strong><br>10<br>6487620<br>6487620<br>10</p><p>参考：<a href="https://blog.csdn.net/qq_21583681/article/details/78572009">C语言中的*和&amp;符号</a></p><hr><h3 id="二维数组和指针"><a href="#二维数组和指针" class="headerlink" title="二维数组和指针"></a>二维数组和指针</h3><p><strong>二维数组的各种申明方式</strong></p><table><thead><tr><th>表示形式</th><th align="left">含义</th></tr></thead><tbody><tr><td>int a[5] [5];</td><td align="left">int类型二维数组</td></tr><tr><td>int ** a;</td><td align="left">指向指针的指针，可用于二维数组</td></tr><tr><td>int * a[5];</td><td align="left">指针数组</td></tr><tr><td>int (*a) [5];</td><td align="left">指向一个具有5个元素的数组的指针</td></tr><tr><td>int * a[5] [5];</td><td align="left">存放指针的二维数组</td></tr><tr><td>int (* a[3]) [4];</td><td align="left">一个3元素数组，每个元素为指向具有4个元素的数组的指针</td></tr></tbody></table><p><strong>二维数组的其他表现形式</strong></p><table><thead><tr><th align="left">表示形式</th><th align="left">含义</th><th align="left">地址</th></tr></thead><tbody><tr><td align="left">a</td><td align="left">二维数组名，指向一维数组a[0]，即0行首地址</td><td align="left">2000</td></tr><tr><td align="left">a+1， &amp;a[1]</td><td align="left">指向一维数组a[1]，即1行首地址</td><td align="left">2016</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">a[0]， *(a+0)， *a</td><td align="left">0行0列元素，a[0] [0]地址</td><td align="left">2000</td></tr><tr><td align="left">a[1]， *(a+1)</td><td align="left">1行0列元素，a[1] [0]地址</td><td align="left">2016</td></tr><tr><td align="left">a[1]+2， *(a+1)+2， &amp;a[1] [2]</td><td align="left">1行2列元素，a[1] [2]地址</td><td align="left">2024</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">* (a[1]+2)， * (*(a+1)+2)， a[1] [2]</td><td align="left">1行2列元素，a[1] [2]的值</td><td align="left">元素值，13</td></tr></tbody></table><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><blockquote><p>数组int a[3] [4] 中的a[2] [1] 用其他形式表示</p></blockquote><p>仔细使用上面的解析方式</p><p><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/1601164D5-1.png" alt="把二维数组拆解成一维数组"></p><p>通过上面的图，可以很直观的得出三种a[2] [1] 的其他表达形式</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">*(*(a+2)+1);*(a[2]+1);int *p &#x3D; &amp;a[0] [0];p[9];&#x2F;&#x2F;p的第10个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考：<a href="http://c.biancheng.net/view/2022.html">C语言二维数组指针（指向二维数组的指针）</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】初刷算法</title>
      <link href="/2020/07/23/%E7%AE%97%E6%B3%95-%E5%88%9D%E5%88%B7%E7%AE%97%E6%B3%95/"/>
      <url>/2020/07/23/%E7%AE%97%E6%B3%95-%E5%88%9D%E5%88%B7%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>做为一个通信工程专业的人，只做过嵌入式软件，对数据结构都还不够了解。现在拿起剑指offer开始刷算法题，真的感觉不太容易。讲一讲做的两道题，过程还蛮折磨人的。</p><ul><li><strong>03数组中重复的数字</strong></li><li><strong>04二维数组的查找</strong></li></ul><hr><h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h2><blockquote><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例 1：</strong></p><p>输入：[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p><p>限制：2 &lt;= n &lt;= 100000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof</a></p></blockquote><p>看到题目之后，想都没想就立马开始敲代码。看看我的第一段代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define ERROR -1int findRepeatNumber(int* nums, int numsSize)&#123;    int i,j;    for(i&#x3D;0;i&lt;numsSize;i++)    &#123;        for(j&#x3D;i+1;j&lt;numsSize;j++)        &#123;            if(nums[i] &#x3D;&#x3D; nums[j])                return nums[i];        &#125;    &#125;    return ERROR;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这几乎是最简单直接，不用动脑的方法了。但它的时间复杂度是有蛮高的，几乎达到了O(n^2)，果然在n=9000的事例中超出时间限制。而且也没有考虑程序的鲁棒性，算是很低级的解法了。</p><p>第二段代码是，学习书上的交换数据元素的方式来解。考虑了空指针、数据元素等负面条件，考虑了程序的鲁棒性，应该是非常好的解法了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define ERROR -1int findRepeatNumber(int* nums, int numsSize)&#123;    if(nums &#x3D;&#x3D; NULL || numsSize &lt;&#x3D; 0)        return ERROR;        for(int i &#x3D; 0; i&lt;numsSize; i++)    &#123;        if(nums[i]&lt;0 || nums[i]&gt;numsSize-1)            return ERROR;    &#125;    for(int i &#x3D; 0; i&lt;numsSize; i++)    &#123;        while(nums[i] !&#x3D; i)        &#123;            if(nums[i] &#x3D;&#x3D; nums[nums[i]])                return nums[i];            int a &#x3D; nums[i];            nums[i] &#x3D; nums[a];            nums[a] &#x3D; a;        &#125;    &#125;    return ERROR;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第三段程序是，书上有所提示的hash表的方式。没有打乱数组原有的顺序，但是新建hash表回占用部分内存，算是用空间换取时间的求解方式。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define ERROR -1int findRepeatNumber(int* nums, int numsSize)&#123;    int hash[numsSize];    if(nums &#x3D;&#x3D; NULL || numsSize &lt;&#x3D; 0)        return ERROR;for(int i &#x3D; 0; i&lt;numsSize; i++)    &#123;        if(nums[i] &lt; 0 || nums[i] &gt; numsSize-1)            return ERROR;    &#125;    for(int i&#x3D;0; i&lt;numsSize; i++)    &#123;        if(hash[nums[i]] !&#x3D; 1 )        &#123;            hash[nums[i]] &#x3D; 1;        &#125;        else             return nums[i];    &#125;    return ERROR;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第四段程序，是参考书上的二分法的方式，既不打乱原有的数组元素，也不用创建新的数组占用空间。但是这个算法好像有问题。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define ERROR -1int CountRange(const int *nums, int numsSize,int start, int end)&#123;    int count &#x3D; 0;    for(int i&#x3D;0; i&lt;numsSize;i++)    &#123;        if(nums[i] &gt;&#x3D; start &amp;&amp; nums[i] &lt;&#x3D; end)            count++;    &#125;    return count;&#125;int findRepeatNumber(int* nums, int numsSize)&#123;    int start &#x3D; 0;    int end &#x3D; numsSize-1;        while (end &gt;&#x3D; start)    &#123;        int middle &#x3D; ((end-start)&gt;&gt;1)+start;        int count &#x3D; CountRange(nums, numsSize, start, middle);        if(end &#x3D;&#x3D; start)        &#123;            if(count&gt;1)                return start;            else                 break;        &#125;        if(count &gt; (middle - start + 1))            end &#x3D; middle;        else             start &#x3D; middle + 1;    &#125;    return ERROR;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入：[0, 1, 2, 0, 4, 5, 6, 7, 8, 9]</p><p>输出：ERROR</p><p>预期结果：0</p><p>因为在中点的时候start-middle和middle-end的count都是5，程序就看后面半段是否有重复的元素了。尔重复的元素在前面半段就被忽略掉了，所以输出为ERROR。所以这个算法还是有问题，需要改进呀。</p><hr><h2 id="二维数组的查找"><a href="#二维数组的查找" class="headerlink" title="二维数组的查找"></a>二维数组的查找</h2><blockquote><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>示例:</p><p>现有矩阵 matrix 如下：</p><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p><p>限制：0 &lt;= n &lt;= 1000 ；0 &lt;= m &lt;= 1000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a></p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool findNumberIn2DArray(int** matrix, int matrixSize, int* matrixColSize, int target)&#123;    int cow &#x3D; 0;    int col &#x3D; *matrixColSize - 1;    if(matrix &#x3D;&#x3D; NULL || matrixSize &lt;&#x3D; 0 || *matrixColSize &lt;&#x3D; 0)    &#123;        return false;    &#125;     while(cow &lt; matrixSize &amp;&amp; col &gt;&#x3D; 0)    &#123;        if(matrix[cow][col] &gt; target)        &#123;            col--;        &#125;        else if(matrix[cow][col] &lt; target)        &#123;            cow++;        &#125;        else        &#123;            return true;        &#125;    &#125;    return false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这道题的思路是：将一个复杂问题，通过分析一个简单具体的例子，来寻找普遍的规律。这是将矩阵右上角的数字元素与目标数字进行对比，依次删除列和行，直至找到相等的元素或遍历完整个矩阵。就像下面所示的步骤。</p><p><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/01065754-360a04e422b14e489869d9c58867f2a1.jpg" alt="img"></p><p>第一遍的时候，在输入矩阵[]的时候，总是出错。还是边界条件、负面条件没有考虑到，还是要多考虑程序的鲁棒性。</p><hr><p>初刷算法，深刻感受到以前写代码的粗糙，代码的鲁棒性做的比较差，只考虑到最理想输入的情况。</p><p>想要成为一名优秀的程序员，以后还要多注意代码的鲁棒性！</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【物联网】03应用领域</title>
      <link href="/2020/07/05/%E7%89%A9%E8%81%94%E7%BD%91-03%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F/"/>
      <url>/2020/07/05/%E7%89%A9%E8%81%94%E7%BD%91-03%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>物联网的应用场景是非常多样化的，包括智能家居、智慧城市、智能工厂等等。但仔细研究这些应用场景，就大概能分出三个大类：面向个人、面向社会和面向企业。我们就通过这三个分类来仔细看看物理网的应用领域吧~</p><hr><h2 id="面向个人的物联网"><a href="#面向个人的物联网" class="headerlink" title="面向个人的物联网"></a>面向个人的物联网</h2><p><strong>IOsL(Internet of smart living)——智能家居、智慧生活</strong></p><ul><li>远程控制：远程打开和关闭电器以避免事故和节约能源</li><li>环境感知：显示室外天气状况，如湿度、温度、压力、风速和雨量，为你做个性化配置</li><li>智能家电：比如带屏幕的冰箱，告诉你里面有什么食物即将过期，需要购买什么配料，在手机上同步推送、购买</li><li>安全监控：摄像头和家庭警报系统，使人们在家里生活能感到安全</li><li>安防系统：检测门窗是否打开和是否有违规行为，来防止入侵者</li><li>能源和水使用：对能源和供水消耗监控，给出节约成本和资源的建议</li><li>更多…</li></ul><p><strong>IOsH(Internet of smart health)——智能健康互联网</strong></p><ul><li>患者监测：监测医院和养老院中老人和患者的状况</li><li>药物检测：控制冰柜内储存疫苗、药品和有机元素的条件</li><li>跌倒检测：帮助独立生活的老年人或残疾人</li><li>活动监测：放置在床垫上的无线传感器，检测睡眠期间呼吸和心率等</li></ul><hr><h2 id="面向社会的物联网"><a href="#面向社会的物联网" class="headerlink" title="面向社会的物联网"></a>面向社会的物联网</h2><p><strong>IOsC(Internet of smart cities)——智慧城市</strong></p><ul><li>建筑健康：监测建筑物、桥梁和历史古迹的振动和材料</li><li>照明系统：智能路灯和天气自适应的照明系统</li><li>安防系统：数字视频监控、消防管理、公共广播系统</li><li>智能交通：智能马路和智能高速，根据气候条件和意外事件(如事故或交通拥堵)发出警告信息和改道</li><li>智能停车：实时监测城市可用停车位，让司机能够找到最近的停车位</li></ul><ul><li><p>空气污染监测：控制工厂的二氧化碳排放，汽车尾气排放</p></li><li><p>森林火灾检测：监测燃烧气体并提前预知火灾情况，以确定警戒区</p></li><li><p>天气监测：天气条件监测，如湿度、温度、压力、风速和降雨，地震预测</p></li><li><p>水质监测：河流和海洋的水质情况</p></li><li><p>河流洪水：监测河流、大坝和水库在雨天的水位变化</p></li><li><p>保护野生动物：利用GPS跟踪项圈，检测野生动物活动情况</p></li></ul><p><strong>IOsE(internet of smart energy)——智能能源</strong></p><ul><li>智能电网：能源消耗监测和管理</li><li>发电站：监测和分析发电站的电力流动，与消费者的智能电表进行双向通信</li><li>电源控制器：用于确定所需能源的AC-DC电源控制器，以提高能源效率，降低能源浪费</li><li>光伏安装：监控和优化太阳能发电厂的性能。</li></ul><hr><h2 id="面向企业的物联网"><a href="#面向企业的物联网" class="headerlink" title="面向企业的物联网"></a>面向企业的物联网</h2><p><strong>IOsI(Internet of smart industry)——智能工业互联网</strong></p><ul><li>爆炸和危险气体：检测工业环境、化工厂周围和矿山内的气体水平和泄漏情况，监测化工厂内的有毒气体和氧气水平，以确保工人和货物的安全</li><li>维护和维修：通过在设备内部安装监测和发送报告的传感器，可以自动提前对设备故障和服务进行早期预测。</li></ul><p><strong>IOsA(internet of smart agriculture)——智能农业互联网</strong></p><ul><li>温室检测：控制温室环境，最大限度地提高水果和蔬菜的产量及其质量</li><li>堆肥：控制苜蓿、干草、稻草等的湿度和温度水平以防止真菌和其他微生物污染</li><li>动物饲养：在露天牧场中放牧的动物的位置和识别</li><li>后代护理：控制动物农场中后代的生长条件，以确保其生存和健康</li><li>现场监测：更好地控制农业施肥、用电和浇水</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 知识扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【物联网】02架构与使能技术</title>
      <link href="/2020/06/18/%E7%89%A9%E8%81%94%E7%BD%91-02%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BD%BF%E8%83%BD%E6%8A%80%E6%9C%AF/"/>
      <url>/2020/06/18/%E7%89%A9%E8%81%94%E7%BD%91-02%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BD%BF%E8%83%BD%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="使能技术"><a href="#使能技术" class="headerlink" title="使能技术"></a>使能技术</h2><p>随着物联网的出现，互联网扩展到我们周围的一切事物。物联网不仅仅是机器对机器的通信、无线传感器网络、传感器网络、2G/3G/4G/5G、以太网、WI-FI、蓝牙、ZigBee、GSM、GPRS、RFID、WI-FI、GPS、微控制器、微处理器等，这些都被认为是使“物联网”应用成为可能的使能技术。</p><p>物联网的使能技术可以分为三类：</p><ol><li>使“物”能够获得信息的技术</li><li>使“物”能够处理信息的技术</li><li>提高安全性和私密性的技术</li></ol><p>前两类可以理解为将“物”变得智能所需要的技术，这确实是物联网与互联网不同的地方。</p><p>第三类不是功能上的要求，而是事实上的要求，如果没有这个要求，物联网的普及率将会严重下降。</p><p><strong>总而言之，物联网不是单一的技术，而是不同硬件和软件技术的结合体。</strong></p><hr><h2 id="物联网架构"><a href="#物联网架构" class="headerlink" title="物联网架构"></a>物联网架构</h2><p>物联网架构由支持物联网的不同技术层组成，它用于说明各种技术的作用是什么，是如何相互关联的。</p><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/image-20200617155741565.png" alt="物联网架构" style="zoom: 67%;" /><hr><h3 id="智能设备-传感器层（smart-device-sensor-layer）"><a href="#智能设备-传感器层（smart-device-sensor-layer）" class="headerlink" title="智能设备/传感器层（smart device / sensor layer）"></a>智能设备/传感器层（smart device / sensor layer）</h3><p>由各种传感器组成，将物理世界和数字世界的连接起来，允许收集和处理实时信息。</p><p>传感器可以测量物理属性，并将其转换为智能设备能理解的电信号。传感器有测量温度、空气质量、速度、湿度、压力、流量、运动和电力等。在某些情况下，它们还可能有一定程度的记忆，使它们能够记录一定数量的测量数据。</p><p>不同类型的传感器用于不同的目的，传感器按其独特用途进行分组，如环境传感器、身体传感器、家用电器传感器和车辆远程信息处理传感器等。</p><hr><h3 id="网关和网络（Gateways-and-Networks-）"><a href="#网关和网络（Gateways-and-Networks-）" class="headerlink" title="网关和网络（Gateways and Networks ）"></a>网关和网络（Gateways and Networks ）</h3><p>大量的传感器将产生大量的数据，需要一个强大的、高性能的有线或无线网络基础设施作为传输媒介。同样需要支持低延迟、带宽或安全性的通信要求。</p><p>当前的网络通常与非常不同的协议捆绑在一起，用作支持机器到机器(M2M)网络及其应用。随着服务于更广泛的物联网服务和应用(如高速事务服务、情景感知应用等)的需求，需要采用各种技术和接入协议的多个网络在异构配置中相互协作。</p><p>诸如通过以太网和Wi-Fi连接的局域网(LAN)，或ZigBee、蓝牙和超宽带(UWB)的个人局域网(PAN)的形式，使大多数传感器连接到网关；对于不需要连接到网关的传感器，可以使用GSM、GPRS和LTE等广域网(WAN)提供到后端服务器/应用程序的连接。</p><hr><h3 id="管理服务层（Management-Service-Layer）"><a href="#管理服务层（Management-Service-Layer）" class="headerlink" title="管理服务层（Management Service Layer）"></a>管理服务层（Management Service Layer）</h3><p>管理服务层通过分析数据、安全控制、流程建模和设备管理，来达到物联网的控制。</p><h4 id="业务和流程规则引擎"><a href="#业务和流程规则引擎" class="headerlink" title="业务和流程规则引擎"></a>业务和流程规则引擎</h4><p>物联网将对象和系统的连接和交互结合在一起，以事件或上下文数据(如货物温度、当前位置和交通数据)的形式提供信息。这是管理服务层的重要功能之一。</p><ul><li><p>其中一些事件需要过滤或路由到后处理系统，例如捕获定期感官数据，</p></li><li><p>而另一些事件则需要对紧急情况做出响应，例如对患者健康状况的紧急情况做出反应。</p></li></ul><p>规则引擎支持决策逻辑的制定，并触发交互式和自动化流程，以实现响应更快的物联网系统。</p><h4 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h4><p>在分析领域，各种分析工具被用来从海量的原始数据中提取相关信息，并以更快的速度进行处理。</p><ul><li><p>内存分析：大量数据缓存在随机存取存储器(RAM)中，而不是存储在物理磁盘中。内存分析减少了数据查询时间，提高了决策速度。</p></li><li><p>流分析：动态数据分析需要实时执行，在几秒钟内做出决定。</p></li></ul><h4 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h4><p>数据管理是管理数据信息流的能力。通过管理服务层的数据管理，可以对信息进行访问、集成和控制。</p><ul><li>数据提取：高层应用程序可以避免处理不必要的数据，并降低数据源隐私泄露的风险。</li><li>数据过滤：如数据匿名化、数据集成和数据同步，用于隐藏信息的细节，同时只提供可用于相关应用的基本信息。</li><li>数据抽象：可以提取信息以提供数据的公共业务视图，从而获得更大的敏捷性和跨域的重用。</li></ul><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>必须在物联网体系结构的<strong>整个维度</strong>上实施安全性，从智能设备/传感器层一直到应用层。系统的安全性可以防止未经授权的人员对系统进行黑客攻击和入侵，从而降低发生风险的可能性。</p><hr><h3 id="应用层（Application-Layer）"><a href="#应用层（Application-Layer）" class="headerlink" title="应用层（Application  Layer）"></a>应用层（Application  Layer）</h3><p>物联网应用层涵盖交通、建筑、城市、生活方式、零售、农业、工厂、供应链、应急、医疗保健、用户互动、文化和旅游、环境和能源等领域。</p><p>下一节将具体讲解这一部分内容。</p>]]></content>
      
      
      <categories>
          
          <category> 知识扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【物联网】01物联网之初见</title>
      <link href="/2020/06/15/%E7%89%A9%E8%81%94%E7%BD%91-01%E7%89%A9%E8%81%94%E7%BD%91%E4%B9%8B%E5%88%9D%E8%A7%81/"/>
      <url>/2020/06/15/%E7%89%A9%E8%81%94%E7%BD%91-01%E7%89%A9%E8%81%94%E7%BD%91%E4%B9%8B%E5%88%9D%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<h2 id="物联网简介"><a href="#物联网简介" class="headerlink" title="物联网简介"></a>物联网简介</h2><p>物联网简称IoT，Internet of Things，通俗的解释就是，用物品连接起来的网络，是物理对象的网络。</p><p>物联网的概念是射频识别(RFID)开发社区的一名成员在1999年提出的，但是因为技术的不成熟，概念一直没有发展成现实。直到最近几年，由于移动设备、嵌入式和无处不在的通信网络、云计算和数据分析技术的出现，它才变得更加贴近实际世界。</p><h2 id="发展目标"><a href="#发展目标" class="headerlink" title="发展目标"></a>发展目标</h2><p>物联网的发展目标可以总结为6个any：</p><p>使物品/设备能够随时（any time）随地（any place）的连接在一起，任何事物（anything）、任何人（anyone）都能随心所欲的使用任何路径/网络（any path/network）来完成任何服务（any service）。</p><blockquote><p>The goal of the Internet of Things is to enable things to be connected anytime, anyplace, with anything and anyone ideally using any path/network and any service.</p></blockquote><img src="https://jacksbuilding.oss-cn-beijing.aliyuncs.com/img/微信截图_20200614232849.png" alt="物联网的6个any" style="zoom:67%;" /><h2 id="物联网特性"><a href="#物联网特性" class="headerlink" title="物联网特性"></a>物联网特性</h2><ol><li><p>互联性（Interconnectivity）</p><p>任何设备都能够通过网络互连互通</p></li><li><p>与物相关服务（Things-related services）</p><p>通过虚拟化的信息命令，可以实现相应实体化的物体的变化</p></li><li><p>异构性、兼容性（Heterogeneity）</p><p>不同的硬件平台和网络，可以通过不同的网络与其他设备或服务平台交互</p></li><li><p>动态变化（Dynamic changes）</p><p>随着系统指令的改变，设备的状态会动态变化，例如睡眠和唤醒、连接和/或断开等</p></li><li><p>超大规模（Enormous scale）</p><p>连接的设备至少比手机、电脑等通信设备高一个量级，处理的信息数据也会更多</p></li><li><p>安全（Safety）</p><p>创建可扩展的安全范例，来保护终端、网络和整个网络中移动的数据，达到保护我们个人数据的安全和我们身体健康的安全的目的</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 知识扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Matlab】常用绘图命令</title>
      <link href="/2020/06/11/Matlab-%E7%BB%98%E5%9B%BE%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/11/Matlab-%E7%BB%98%E5%9B%BE%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>对Matlab的基本绘图命令进行介绍。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">figure(1);#绘图界面1subplot(2,1,1);#画面被分为两个小图，小图1plot(x,y);#画图#plot(x,y,&#39;-k&#39;);#画黑色实线#plot(t,x,t,y);#同时画两条线#plot(t,y(t,length(t)));subplot(2,1,2);stem(t_n,f);#绘制茎状图title(&#39;x&amp;y&#39;);#设置标题xlabel(&#39;t&#39;);#坐标系命名ylabel(&#39;y&#39;);legend(&#39;x line&#39;,&#39;y line&#39;);#给线添加名称text(x_position,y_position,[&#39;N&#x3D;&#39;,num2str(N)]);#任意位置添加文字grid on;#打开网格axis([1.1*min(x) 1.1*max(x) 1.1*min(y) 1.1*max(y)]);#设置坐标系长度#axis(&#39;square&#39;);#将坐标系设置为方形#axis(&#39;off&#39;);#关闭坐标系<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">hold on;#已经画的线保持，不被清除，再画线时在原图上添加hold off;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">get(gcf,&#39;doubleBuffer&#39;,&#39;on&#39;);drawnow;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">yyaxis left#同一张图，左右使用不同y轴坐标系yyaxis right<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">线型</th><th align="center">- 实线</th><th align="center">. 点线</th><th align="center">-. 虚点线</th><th align="center">– 波折线</th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">点型</td><td align="center">. 圆点</td><td align="center">+ 加号</td><td align="center">* 星号</td><td align="center">x x星号</td><td align="center">o 小圆</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">颜色</td><td align="center">y 黄色</td><td align="center">r 红色</td><td align="center">g 绿色</td><td align="center">b 蓝色</td><td align="center">w 白色</td><td align="center">k 黑色</td><td align="center">m 紫色</td><td align="center">c 青色</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【生活随笔】疫情期间感悟</title>
      <link href="/2020/03/19/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E7%96%AB%E6%83%85%E6%9C%9F%E9%97%B4%E6%84%9F%E6%82%9F/"/>
      <url>/2020/03/19/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94-%E7%96%AB%E6%83%85%E6%9C%9F%E9%97%B4%E6%84%9F%E6%82%9F/</url>
      
        <content type="html"><![CDATA[<p>疫情持续到现在，我感触比较大的是：自己从来没有这么想去学校。在此之前，我经常会想要在忙碌的学习中抽离出来，可以有一大段的时间停下来。可突然实现时，却发现自己更多的是感到焦虑和迷茫。并且，开始怀念起以前忙碌有序的学习和生活状态来。这些，也都是我身边大多数人的状态。</p><p>突如其来的疫情，打乱了年前的各种计划。因为需要少聚集，取消了和高中同学的聚会；因为需要控制出门与人接触，也没有玩到早就想去的密室逃脱；因为疫情这段时间没法出门，我每天就呆在家里看看电视，打打游戏。在这个阶段，健康自然是最重要的，能够在父母身边也是一种幸福，但同时，心里还是感到非常空虚和无聊。</p><p>所以决定开始找点事情做:在家里学习自己做菜，现在做的还算有模有样了；既然不能出门运动，就在家里每天做俯卧撑、仰卧起坐，感觉也挺好的；开学遥遥无期，就在家打开论文学习，虽然还是没有很好的学习状态，但是在晚上打游戏打得更心安理得了，哈哈。</p><p>很多人觉得，经过这次疫情，活着最重要，过得开心最重要，和家人在一起最重要的，我当然也是这样认为的，但是我们要认识到，疫情不是让我们暂时逃避面对现实的机会。因为疫情过后，我们还是得回归现实，该学习的努力学习，该工作的努力工作，但到那时候，你是否已经准备好了呢？</p><p>知乎之前有个话题：面对疫情，我们普通人能够做什么？我想大概就是，做好眼前的事情，保护好身边的人。现在或许有很多我们没办法控制的因素，比如因为疫情，学习和工作受到影响，很多人会觉得很焦虑或沮丧。但是不管在怎样的情况下，我们不能去抱怨我们无法控制的东西，而是应该承担起责任。疫情之下，提升自己的竞争力，就是可以并且努力去控制的事情。希望大家在这个期间，多充实，多提升自己。</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
